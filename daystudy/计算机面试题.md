# 计算机面试题

[TOC]



## 小的知识点总结

```
1、Ipv6长度为128位，采用冒号分十六进制表示法，共32位十六进制数
2、IP地址:192.168.0.1/22  /22代表二进制的子网掩码有多少个1，子网掩码用来区分IP地址的网络号和主机号，与子母掩码全为1的这部分是网络号，全为0的部分是主机号，有10位主机号，那该网段有2的10次方共有1024个地址可用，主机号全为0的地址代表该网段，主机号全为1的地址代表该网段的广播地址。
```

### 智力&&场景设计类题

#### 设计类AutoReset

设计一个类AutoReset， 能够实现让value的值在特定作用域里面临时设置为其他值，并在离开特定作用域后恢复原来的值，如下所示，value在1处为false, 2处值为true，在3处值为false。在你设计的Reset在使用的时候有什么需要注意的地方嘛？

```cpp
bool value = false;
//1. value is false
{
    AutoReset<bool> mark_inside(&value, true);
   //2. value is true
}
// 3. value is false
```

```cpp
class AutoReset{
public:
   //传进来value原值的指针，和新的值
    AutoReset(int *scoped_variable,int new_value){
   //将scoped_variable这个指针中的值，即value的原值，保存在original_value里，以待将来恢复
        original_value=*scoped_variable;
  // value的地址是作为参数（scoped_variable）传下来的，所以一旦离开构造函数，就没办法直接得知value的地址了
   // 因此要将scoped_variable这个指针所指向的地址，即value的地址，保存在成员scoped_variable_里,留待将来恢复value的值时使用 
        //拷贝传进来指针的地址；
        scoped_variable_=scoped_variable;
// 将new_value通过scoped_variable_这个指针（指向外面的value）赋给value，达到在作用域内value的值修改为 new_value的作用
        *scoped_variable=new_value;
    }
 // 当离开作用域的时候，调用析构函数，这时通过之前保存的指针scoped_variable_（指向外面的value）
  // 把之前保存的value的原值（original_value = 100）赋还给value，于是花括号外的value又变回了100 
    ~AutoReset(){
        *scoped_variable_=orignal_value;
    }
private:
    int *scoped_variable_; //指针记录原本值的地址;
    int original_value;  //记录原来的值;
};
```

模板的实现

```cpp
template<class T>
class AutoReset{
public:
    AutoReset(T *ptr,T new_Val){
        oldVal_=*ptr; //先记录原来的值;
        ptr_=ptr;	//记录指针地址;
        *ptr=new_Val; //赋予新的值;
    }
    ~AutoReset(){
        *ptr = oldVal_;
    }
private:
    T* ptr_;
    T oldVal_;
};
```



求函数f(n, k), n, k为正整, 返回数字x, 使得x^k == n，精确到小数点后5位。

```cpp
#include<iostream>
#include<cmath>
using namespace std;

double f(int n,int k){
    if(n==0) return 0.0;
    else if(n==1) return 1.0;
    double low = 0.0;
    double high = n;
    while(high-low > 1e-5){
        double mid=low+(high-low)/2.0;
        double val=pow(mid,k);
        if(val<n){
            low=mid;
        }else {
            high=mid;
        }
    }
    return high;
}

int main(){
    int x,n;
    cin>>x>>n;
    cout<<f(x,n)<<endl;
    return 0;
}

```

#### 换啤酒饮料问题

> 题目描述：现有N瓶啤酒，3个空瓶换一瓶，7个瓶盖换一瓶。问最后能喝到多少瓶啤酒？

```cpp
#include<iostream>
using namespace std;

int getnum(int emptyBottle,int bottleCap){
    if(emptyBottle<3&&bottleCap<7) return 0;
    else{
        int bottleCount=emptyBottle/3+emptyBottle%3+bottleCap/7;
        int bottleCover=bottleCap/7+bottleCap%7+emptyBottle/3;
        return emptyBottle/3+bottleCap/7+getnum(bottleCount,bottleCover);
    }
}

int main(){
    int n;
    cin>>n;
    int num=getnum(n,n);
    cout<<num+n<<endl;
    return 0;
}
```



## C/C++语言

##### 数组指针和指针数组

> **数组指针**，也称行指针。假设有定义`int (*p)[n]`；且`()`优先级高，可以说明`p`是一个指针，且指向一个整形的一维数组。这个一维数组的长度是`n`，也可以说是`p`的步长，也就是说执行`p+1`，`p`要跨过`n`个整形数据的长度。如要将二维数组赋给一指针，应这样赋值：
>
> ```cpp
> int a[3][4];  
> int (*p)[4];  //该语句是定义一个数组指针，指向含4个元素的一维数组
> p = a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
> p++;          //该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]
>               //所以数组指针也称指向一维数组的指针，亦称行指针。
> ```
>
> 访问数组中第i行j列的一个元素，有几种操作方式，`*(p[i]+j)`、`*(*(p+i)+j)`、`(*(p+i))[j]`、`p[i][j]`。其中，优先级：`()>[]>*`。**这几种操作方式都是合法的**。

##### i++和++i的编译

```c++
#include <stdio.h>
int main(){
    int i = 2;
    int j = 2;
    j += i++; //先赋值后加
    printf("i= %d, j= %d\n",i, j); //i= 3, j= 4
    i = 2;
    j = 2;
    j += ++i; //先加后赋值
    printf("i= %d, j= %d",i, j); //i= 3, j= 5
}
```

##### 静态链接和动态链接

> **静态链接**，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行。
>
> 生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。
>
> 而**动态链接**，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。
>
> 生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。

##### 编译过程

预处理、编译、汇编、链接

预处理：

- 删除 #define 并展开宏定义
- 处理所有的条件预编译指令，如 "#if"，"#ifdef"，"#endif"等
- 插入头文件到 "#include" 处，可以递归方式进行处理
- 删除所有的注释
- 添加行号和文件名标识，以便编译时编译器产生调试用的行号信息
- 保留所有 #pragma 编译指令（编译器需要用）
  命令示例如下：
- gcc -E hello.c -o hello.i

编译：

编译过程就是将预处理后得到的预处理文件（如hello.i）进行==词法分析、语法分析、语义分析、优化后，生成汇编代码文件==。
经过编译后，得到的汇编代码文件（如，hello.S）还是一个可读的文本文件。
命令示例如下：

- gcc -S hello.i -o hello.s

- gcc -S hello.c -o hello.s

  汇编：

汇编器将编译得到的汇编代码文件转换成机器指令序列。
汇编的结果是一个可重定位目标文件（如，hello.o）其中包含的是不可读的二进制代码。
命令示例如下：

- gcc -c hello.s -o hello.o
- gcc -c hello.c -o hello.o
- as hello.s -o hello.o


链接：

链接过程将多个可重定位目标文件合并以生成可执行目标文件。
命令示例如下：

- gcc -static -o myproc main.o test.o
- ld -static -o myproc main.o test.o


##### extern C

```cpp
#ifdef __cplusplus //而这一部分就是告诉编译器，如果定义了__cplusplus(即如果是cpp文件，因为cpp文件默认定义了该宏),则采用C语言方式进行编译
extern "C"{
    #include"moduleA.h"
    #endif
    … //其他代码

    #ifdef __cplusplus
}
#endif
```

**extern "C"**的主要作用就是为了能够正确**实现C++代码调用其他C语言代码**。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。

由于C++支持**函数重载**，因此编译器编译函数的过程中会将函数的**参数类型**也加到编译后的代码中，而不仅仅是**函数名**；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括**函数名**。

> 这个功能主要用在下面的情况：
>
> 1. C++代码调用C语言代码
>
>    ```c++
>    //extern示例
>    //在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译
>    extern "C" int strcmp(const char *s1, const char *s2);
>    ```
>
> 2. 在C++的头文件中使用
>
>    ```c++
>    //在C++程序里边声明该函数
>    extern "C"{
>        #include <string.h>//string.h里边包含了要调用的C函数的声明
>    }
>    ```
>
> 3. 在多个人协同开发时，可能有的人比较擅长C语言，而有的人擅长C++，这样的情况下也会有用到

##### 宏define

> \#define命令是一个**宏命令**，它用来将一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。
>
> 该命令有两种格式：一种是不带参数的宏定义，另一种是带参数的宏定义。
>
> 1. **不带参数的宏定义**的声明格式如下所示：
>
>    ```cpp
>    #define  宏名  字符串
>
>    例：#define  PI  3.1415
>    ```
>
> 2. **带参数的宏定义**的声明格式如下所示：
>
>    ```c
>    #define  宏名（参数列表）  宏
>                
>    例：#define  MAX(x,y)  ((x)>(y)?(x):(y))
>    ```
>    
>    由程序编译的四个过程，知道**宏是在预处理阶段被展开的。**在预处理阶段是不会进行**语法检查、语义分析的**，宏被暴力替换，正是因为如此，如果不注意细节，宏的使用很容易出现问题;
>    
>    ==宏的使用过程中要注意加上括号==；
>    
>    在C++中为了安全性，我们就要少用宏。
>    
>    不带参数的宏命令我们可以用**常量const**来替代，比如`const int PI = 3.1415`，可以起到同样的效果，而且还比宏安全，因为这条语句会在编译阶段进行语法检查。
>    
>    而带参数的宏命令有点类似函数的功能，在C++中可以使用**内联函数或模板**（模板在后面章节会详细讲解）来替代，用**inline**关键字定义函数，即声明此函数为内联函数，内联函数与宏命令功能相似，是在调用函数的地方，用函数体直接替换。但是内联函数比宏命令安全**，因为内联函数的替换发生在编译阶段，同样会进行语法检查、语义分析**等，而宏命令发生在预编译阶段，属于暴力替换，并不安全。

##### inline内联函数

C++ **内联函数**是通常与类一起使用。如果一个函数是内联的，那么在编译时，**编译器会把该函数的代码副本放置在每个调用该函数的地方**。

1. **为什么使用内联函数？**

   函数调用是有调用开销的，执行速度要慢很多，调用函数要先保存寄存器，返回时再恢复，复制实参等等。

   如果本身函数体很简单，那么函数调用的开销将远大于函数体执行的开销。为了减少这种开销，我们才使用内联函数。

2. **内联函数使用的条件**

   - 内联是以代码复制为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：

     （1）如果函数体内的**代码比较长**，使用内联将导致内存消耗代价较高。

     （2）如果函数体内出现**循环**，那么执行函数体内代码的时间要比函数调用的开销大。

   - 内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。

**特征**

- 相当于把内联函数里面的内容写在调用内联函数处；
- 相当于不用执行进入函数的步骤，直接执行函数体；
- 相当于宏，却比**宏多了类型检查，真正具有函数特性**；
- 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
- 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

```c++
// 声明1（加 inline，建议使用）
inline int functionName(int first, int second,...);

// 声明2（不加 inline）
int functionName(int first, int second,...);

// 定义
inline int functionName(int first, int second,...) {/****/};

// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```

**编译器对 inline 函数的处理步骤**

1. 将 inline 函数体复制到 inline 函数调用点处；
2. 为所用 inline 函数中的局部变量分配内存空间；
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

**优缺点**

优点

1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，会做==安全检查或自动类型转换==（同普通函数），而宏定义则不会。
3. 在类中声明同时定义的成员函数，==自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能==。
4. 内联函数在运行时可调试，而宏定义不可以。

缺点

1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

##### python和C++语言的区别

在 Python 中，源代码会被编译为更低级的一种形式，我们称之为==字节码==。字节码是一串指令，和 CPU 的指令集类似。但是字节码并不直接被 CPU 执行，而是在虚拟机中执行的。

我们在运行python的时候感受不到它的编译过程，事实上两种语言执行过程中，都会先编译成字节码，然后交给虚拟机执行。

python还有一个重要的特性，就是交互式命令，你可以敲入一行Python语句时，然后立刻回车执行，这个过程Python同样一会先转为字节码，然后执行。而这个交互式命令行这个特性，在很多编译型语言里是没有的。同样因为没有显示的调用编译程序，很多人将执行 Python 源文件的程序叫做 Python 解释器。

Python 之所以称为解释型语言，是因为它没有显示的调用编译操作，表现出解释型的特性比较多而已。但事实上，编译是存在的，具体怎么编译就看语言的实现了，也就是解释器的设计

1. 语言类型不一样：python是一种基于解释型的语言，解释器回逐行的读取代码，首先将python编译为字节码；而C语言是一种编译语言，完整的源代码将直接编译为机器代码，有CPU直接执行。
2. 内存管理：python使用垃圾收集器进行内存管理，在C语言中程序必须自己进行内存管理；
3. 全局变量不同：在C语言中，声明全局变量，如果值是恒定的，那么可以直接用#define声明，如果只是声明全局，并且变量的值是可变的，那么直接类似int a 就可以了。。在python中，声明全局变量时，需要加上global，类似global a，在函数里面使用的时候需要先声明global a ，否则直接用a那么python会重新创建一个新的本地对象并将新的值赋值给他，原来的全局变量的值并不变化。

##### c++11的新特性

**冒号表达式**：

```cpp
for(int num:nums){
    cout<<num<<endl;
}
//上面的代码等价于
for(int i=0;i<nums.size();i++){
    cout<<nums[i]<<endl;
}
```

**初始化成员列表**

- 成员初始化类表只适用于构造函数
- 必须用这种格式来初始化**const类型和引用类型变量**
- 初始化代表为变量分配内存. 变量在其定义处被[编译器](https://so.csdn.net/so/search?q=编译器&spm=1001.2101.3001.7020)初始化(编译时). 在函数中, 函数参数初始化发生在函数调用时(运行时).
- **C++中, 类成员的初始化于初始化列表中完成, 先于构造函数体执行. 即成员真正的初始化发生在初始化列表中, 而不是构造函数体中.**
- 对于本身就是类对象的成员来说，使用成员初始化列表的效率更高（直接调用复制构造函数或转换函数，代替了【调用默认构造函数，再使用赋值运算符给目标对象赋值】或【未重新定义赋值运算符时：调用默认构造函数，再调用转换函数构造临时对象，最后将临时对象赋给目标对象】【重新定义赋值运算符后：调用默认构造函数，再使用定义的赋值运算符给目标对象赋值】的步骤）
- 在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。**所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。**在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的
- 全局变量、文件域的静态变量和**类的静态成员变量在main执行之前的静态初始化过程中分配内存并初始化**；**局部静态变量（一般为函数内的静态变量）在第一次使用时分配内存并初始化**。这里的变量包含内置数据类型和自定义类型的对象。

**智能指针**：见下

**类型转换**：见下

**右值引用和移动语义**：见下

**lambda表达式**：见下



##### **nullptr和NULL区别**

​			NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议以后还是都用nullptr替代NULL吧，而NULL就当做0使用。

##### malloc和calloc、realloc、new的区别

malloc调用形式为(类型*)malloc(size)：在内存的动态存储区中分配**一块**长度为“size”字节的连续区域，返回该区域的首地址。
calloc调用形式为(类型*)calloc(n，size)：在内存的动态存储区中分配**n块**长度为“size”字节的连续区域，返回首地址。
realloc调用形式为(类型*)realloc(*ptr，size)：将**ptr内存大小增大到size**。

函数原型：

```cpp
void *malloc( size_t size ); //分配的大小
void *calloc( size_t numElements, size_t sizeOfElement ); // 分配元素的个数和每个元素的大小
//定义
void *malloc(size_t size);
void free(void *ptr);
void *calloc(size_t nmemb, size_t size);
void *realloc(void *ptr, size_t size);

```

> malloc和new从申请的内存所在位置、返回类型安全性、内存分配失败时的返回值、是否需要指定内存大小这四点区分。
>
> 1、申请的内存所在位置不同：new操作符从**自由存储区**（free store）上为对象动态分配内存空间。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。malloc函数**从堆上动态分配内存**。堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。
>
> 2、返回类型安全性不同：new操作符内存分配成功时，返回的是**对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符**。malloc内存分配成功则是**返回void *** ，需要通过强制类型转换将void*指针转换成我们需要的类型。
>
> 3、内存分配失败时的返回值不同：new内存分配失败时，会抛出**bad_alloc异常，它不会返回NULL。malloc分配内存失败时返回NULL**。
>
> 4、是否需要指定内存大小不同：使用new操作符申请内存分配时**无须指定内存块的大小**，编译器会根据类型信息自行计算。malloc则需要**显式地指出所需内存的尺寸**。
>
> 5.new/delete是C++关键字，需要**编译器支持**。malloc/free是**库函数，需要头文件支持**。
>
> 6.C++**允许重载new/delete操作符**，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。**而malloc不允许重载。**

memcpy函数，realloc函数能不能在c++中使用，不能，**因为这些函数进行的都是内存值拷贝（也就是对象的浅拷贝），会发生浅拷贝这个严重的问题！**

> malloc和calloc函数在参数个数、初始化内存空间、函数返回du值上有区别：
>
> 1、参数个数上的区别：
>
> malloc函数：malloc(size_t size)函数有一个参数，即要**分配的内存空间的大小**。
>
> calloc函数：calloc(size_t numElements,size_t sizeOfElement)有两个参数，分别为**元素的数目和每个元素的大小，这两个参数的乘积就是要分配的内存空间的大小。**
>
> 2、初始化内存空间上的区别：
>
> malloc函数：**不能初始化所分配的内存空间**，在动态分配完内存后，里边数据是随机的垃圾数据。
>
> calloc函数：**能初始化所分配的内存空间**，在动态分配完内存后，自动初始化该内存空间为零。

##### strcpy和memcpy的区别

> 1）**复制的内容不同**。strcpy只能复制字符串，而memcpy可以复制任意类型的内容。strcpy只用于字符串复制，并且还会复制字符串的结束符。memcpy对于复制的内容没有限制，用途更广。
> 2）**复制的方法不同**。strcpy不需要指定长度，遇到结束符’\0’才会结束，所以容易溢出。memcpy则是根据第三个参数决定复制的长度
> 3）**用途不同**。通常在复制字符串时用strcpy，在复制其他类型数据时一般用memcpy。

**Strcpy实现**

```cpp
char* my_strcpy(char* dest, const char* src){
	if(dest == NULL || src == NULL) return NULL;
	char* res = dest;
	while(*dest != '\0'){
		*dest++ = *src++;
	}
	return res;
}
```

**memcpy实现**

考虑内存重叠；

```cpp
//dst:目的地址;src:源地址：n:要拷贝的字节数;
//函数实现功能：模拟实现从存储区src复制n个字符到存储区dst;
void* memecpy(void* dst,void* src,size_t count){ 
    
    if(dst==src||count==0) return dst;
    if(dst==nullptr||src==nullptr) return nullptr;
    
    char *pdst=(char*)dst;
    char *psrc=(char*)src;
    int cnt=count;
    
    //如果出现的内存交叠：加上拷贝字节数从后向前开始拷贝
    if(pdst>psrc&&pdst<(psrc+count)){
        pdst+=(cnt-1);
        psrc+=(cnt-1);
        while(cnt--){
            *psdt--=*psrc--;
        }
     //没有内存交叠，自前向后拷贝：
    }else{
        while(cnt--){
            *pdst++=*psrc++;
        }
    }
    return dst;
}
```



##### **手写字符串函数**

**strcmp**：字符串比较函数；

```cpp
int strcmp(const char* s1,const char *s2){
    assert(s1!=nullptr&&s2!=nullptr);
    while(*s1==*s2){
        if(*s1=='\0') return 0;
        s1++;
        s2++;
    }
    return *s1-*s2;
}
```

**strcat**:字符串拼接函数,将所有src字符追加到dest所指向的字符串结尾；

```cpp
char *strcat(const char *dest,const char *src){
    assert((dest!=nullptr)&&(src!=nullptr));
    //将目的字符串的起始位置先保存，最后返回它的头指针;
    //先找到dest的结束位置，再把src拷贝到dest中，记得最后加上'\0';
    char *ret=dest;
    while(*dest!='\0'){
        ++dest;
    }
    while(*src!='\0'){
        *(dest++)=*(src++);
    }
    *dest='\0';
    return ret;
}
```

##### 实现一个string类

```cpp
#include<iostream>
#include<cstring>

using namespace std;

class Mystring{
public:
    //构造函数
    Mystring(const char *str=nullptr){
        if(str!=nullptr){
            m_data=new char[strlen(str)+1];
            strcpy(m_data,str);
        }else{
            m_data=new char[1];
            *m_data='\0';
        }
    }
    //拷贝构造函数
    Mystring(const Mystring& other){
        m_data=new char[strlen(other.m_data)+1];
        strcpy(m_data,other.m_data);
    }
    //拷贝赋值函数
    Mystring& operator=(const Mystring& other){
        //避免自我赋值;
        if(this==&other){
            return *this;
        }
        delete[] m_data;//先把原有空间删除
        m_data=new char[strlen(other.m_data)+1];//开辟新的空间，
        strcpy(m_data,other.m_data);//拷贝;
        return *this;
    }

    ~Mystring(){
        delete[] m_data;
        m_data=nullptr;
    }
private:
    char *m_data;
};

```



##### 智能指针

**智能指针**是利用了一种叫做**RAII**（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。

> 解决了空指针、野指针的问题；内存重复释放、内存泄露；new 和delete不匹配

因为智能指针就是一个**类**，当超出了类的作用域时，类会自动调用**析构函数**，自动释放资源。这样程序员就不用再担心内存泄露的问题。

简单实现：

```cpp
#include<iostream>
using namespace std;

//智能指针的简单实现
template<class T>
class SmartPtr{
public:
    SmartPtr(T*ptr = nullptr):_ptr(ptr){}

    ~SmartPtr(){
        if (_ptr){
            delete _ptr;
            _ptr = nullptr;
        }
    }
    T& operator*(){ 
        return *_ptr; 
    }
    T* operator->(){ //返回指向空间的内容
        return _ptr; 
    }
private:
    T* _ptr;
};

//使用方式
void MergeSort(int *a, int n){
    int *tmp = (int*)malloc(sizeof(int)*n);
    SmartPtr<int> sp(tmp);//把tmp指针委托给sp对象
    //……
}
//主要就是体现了智能指针可以构造时初始化，析构时释放资源
```

**C++ 标准库（STL）中**

头文件：`#include <memory>`

**C++ 98**

```c++
std::auto_ptr<std::string> ps (new std::string(str))；
```

**C++ 11**

1. shared_ptr
2. unique_ptr
3. weak_ptr
4. auto_ptr（被 C++11 弃用）

- Class shared_ptr 实现**共享式拥有（shared ownership）概念**。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。
- Class unique_ptr 实现**独占式拥有（exclusive ownership）**或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。

###### shared_ptr

**多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。**

`make_shared<T>args`:  返回一个shared_ptr,指向一个动态分配的类型为T的对象。使用`args`初始化对象；

`shared_ptr<T>p(q)`: p是shared_ptr q的一个拷贝，此操作会递增q中的计数器，q中的指针必须能转换为T*;

p=q: p和q

- shared_ptr**多个指针指向相同的对象**。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。==shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。==

- 初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。==不能将指针直接赋值给一个智能指针==，一个是类，一个是指针。例如std::shared_ptr<int> p4 = new int(1);的写法是错误的

- 拷贝和赋值。==拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存==。后来指向的对象引用计数加1，指向后来的对象。

- get函数获取原始指针

- 注意不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存;

- ==注意避免循环引用==，shared_ptr的一个最大的陷阱是循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏

- ```cpp
  int main()
  {
  	//拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存
  	int a = 10;
  	shared_ptr<int>ptra = make_shared<int>(a);
  	shared_ptr<int>ptra2(ptra);//copy
  	cout << ptra.use_count() << endl;  //2
  
  	int b = 20;
  	int* pb= &a;
  	//shared_ptr<int>ptrb = pb;//error;一个是类，一个是指针；不一样；
  	shared_ptr<int>ptrb = make_shared<int>(b);
  	ptra2 = ptrb;//assign，赋值
  	pb = ptrb.get();//获取原始指针；
  
  	cout << ptra.use_count() << endl;//1
  	cout << ptrb.use_count() << endl;//2;
  	return 0;
  }
  ```

实现原理：**有一个引用计数的指针类型变量m_count，专门用于引用计数，使用拷贝构造函数和赋值拷贝构造函数时，引用计数加1，当引用计数为0时，释放资源**。我们先来定义类：

```cpp
#include<bits/stdc++.h>

using namespace std;

template<typename T>
class smart_ptr{
public:
    //无参构造
    smart_ptr():_count(0),_ptr((T*)(0)){}
    //有参构造
    smart_ptr(T* ptr = nullptr):_ptr(ptr){
        if(ptr){
            _count = new int(0);
            ++(*_count);
        }
        cout << "Constructor is succeed!" << endl;  
    }
    //左值:复制，拷贝构造函数
    smart_ptr(const smart_ptr<T>&other){
        _count = other._count;
        _ptr = other._ptr;
        ++(*_count);
        cout << "Copy constructor is succeed!" << endl; 
    }

    //右值拷贝：a=b，b里面的所有权给a，b指向空
    smart_ptr(smart_ptr<T>&& other){
        _ptr = other._ptr;
        if(_ptr){
            _count = other._count; //引用计数不用改变
            other._ptr = nullptr;
            cout << "move constructor is succeed!" << endl; 
        }
    }

    T* operator->() const{
        return _ptr;
    }

    T& operator*() const{
        return *_ptr;
    }

    //重载operator= 
    smart_ptr<T>& operator=(const smart_ptr<T>& other){
        if(this == &other){
            return *this;
        }
    // 《C++ primer》：“这个赋值操作符在减少左操作数的使用计数之前使other的使用计数加1，  
    // 从而防止自身赋值”而导致的提早释放内存  
        ++(*other._count);
    // 如果原来的shared_ptr已经有对象，则让其引用次数减少1，判断是否为0，为零调用delete
        --(*_count);
        if(this->_ptr &&(*_count) == 0){
            delete _ptr;
            _ptr =nullptr;
            delete _count;
            _count = nullptr;
        }
        //赋值
        this->_ptr = other._ptr;
        this->_count = other._count;
        cout << "Assignment operator overloaded is succeed!" << endl;  
        return *this;
    }
    //析构函数
    ~smart_ptr(){
        --(*_count);
        if(_ptr && (*_count) == 0){
            delete _ptr;
            _ptr = nullptr;
            delete _count;
            _count = nullptr;
            cout << "Destructor is succeed!" << endl; 
        }
    }

    int get_use_count() const{
        if(_ptr){
            return *_count;
        }
        return 0;
    }
private:
    int * _count;
    T* _ptr;
};

int main() {  
    // Test Constructor and Assignment Operator Overloaded  
    smart_ptr<int> p1(new int(0));  
    cout << "p1 use count " << p1.get_use_count()<<endl;

    // Test Copy Constructor  
    smart_ptr<int> p2(p1);  

    cout << "p2 use count " << p2.get_use_count() <<endl;

    // Test Assignment Operator Overloaded  
    p2 = p1;  
    cout << "p2 use count" << p2.get_use_count() <<endl;

    smart_ptr<string>p4(new string("abc"));

    cout << "p4 use count "<< p4.get_use_count() << endl;

    smart_ptr<string>p5(p4);

    cout << "p4 use count " << p4.get_use_count() <<endl;
    cout << "p5 use count " << p5.get_use_count() << endl;

    return 0;  
} 

/*
Constructor is succeed!
p1 use count 1
Copy constructor is succeed!
p2 use count 2
Assignment operator overloaded is succeed!
p2 use count2
Constructor is succeed!
p4 use count 1
Copy constructor is succeed!
p4 use count 2
p5 use count 2
Destructor is succeed!
Destructor is succeed
*/

```



```cpp
#include<iostream>
#include<stdlib.h>
using namespace std;

template <typename T>  
class mysharedPtr {  
public:  
    mysharedPtr(T* p = NULL);  
    ~mysharedPtr();  
    mysharedPtr(const mysharedPtr<T>& other);  
    mysharedPtr<T>& operator=(const mysharedPtr<T>& other);  
private:  
    T* m_ptr;  //指针
    unsigned int* m_count;  //应用计数指针；
};  

//构造函数，有参构造，复制指针，增加计数器；
template <typename T>  
mysharedPtr<T>::mysharedPtr(T* p) {  
    m_ptr = p;  
    m_count = new unsigned int(0);  
    ++(*m_count);  
    cout << "Constructor is succeed!" << endl;  
} 

//析构函数；结果为0时，说明没有智能指针对象指向我们的内存资源了，那我们就要释放我们的内部资源
template <typename T>  
mysharedPtr<T>::~mysharedPtr() {  
    --(*m_count);  
    if ((*m_count) == 0) {  
        delete[] m_ptr;  
        m_ptr = NULL;  
        delete[] m_count;  
        m_count = NULL;  
        cout << "Destructor is succeed!" << endl;  
    }  
}  

//拷贝构造函数
template <typename T>  
mysharedPtr<T>::mysharedPtr(const mysharedPtr<T>& other) {  
    m_ptr = other.m_ptr;  
    m_count = other.m_count;  
    ++(*m_count);  
    cout << "Copy constructor is succeed!" << endl;  
}  

//赋值构造函数;赋值构造函数里面，我们先防止自赋值的情况发生，需要先释放左操作对象资源，再将对象指向同一块内存资源。
template <typename T>  
mysharedPtr<T>& mysharedPtr<T>::operator=(const mysharedPtr<T>& other) {  
    // 《C++ primer》：“这个赋值操作符在减少左操作数的使用计数之前使other的使用计数加1，  
    // 从而防止自身赋值”而导致的提早释放内存  
    ++(*other.m_count);  
    --(*m_count);  
    // 将左操作数对象的使用计数减1，若该对象的使用计数减至0，则删除该对象  
    if ((*m_count) == 0) {  
        delete[] m_ptr;  
        m_ptr = NULL;  
        delete[] m_count;  
        m_count = NULL;  
        cout << "Left side object is deleted!" << endl;  
    }  
    m_ptr = other.m_ptr;  
    m_count = other.m_count;  
    cout << "Assignment operator overloaded is succeed!" << endl;  
    return *this;  
}  
```

```cpp
int main() {  
    // Test Constructor and Assignment Operator Overloaded  
    mysharedPtr<int> p1(new int(0));  
    p1 = p1;  
    // Test Copy Constructor  
    mysharedPtr<int> p2(p1);  
    // Test Assignment Operator Overloaded  
    mysharedPtr<int> p3(new int(1));  
    p3 = p1;  
    system("Pause");  
    return 0;  
} 
/*
输出结果为：
Constructor is succeed!
Assignment operator overloaded is succeed!
Copy constructor is succeed!
Constructor is succeed!
Left side object is deleted!
Assignment operator overloaded is succeed!
Destructor is succeed!
*/
```

shared_ptr会不会出现内存泄漏，怎么解决？

> 会出现内存泄露问题。
>
> 共享指针的循环引用计数问题：当两个类中相互定义shared_ptr成员变量，同时对对象相互赋值时，就会产生循环引用计数问题，最后引用计数无法清零，资源得不到释放。
>
> 可以使用weak_ptr，weak_ptr是**弱引用**，weak_ptr的**构造和析构不会引起引用计数的增加或减少**。我们可以将其中一个改为weak_ptr指针就可以了。比如我们将class B里shared_ptr换成weak_ptr。

shared_ptr是线程安全的吗？

> 因为 shared_ptr 有两个数据成员，读写操作不能原子化”使得**多线程读写同一个 shared_ptr 对象需要加锁**。
>
> 虽然通过原子操作解决了引用计数的计数的线程安全问题， 但是智能指针指向的对象的线程安全问题，智能指针没有做任何的保证。  首先智能指针有两个变量，一个是指向的对象的指针，还有一个就是我们上面看到的引用计数管理对象， 当智能指针发生拷贝的时候，标准库的实现是先拷贝智能指针，再拷贝引用计数对象（拷贝引用计数对象的时候，会使use_count加一），这两个操作并不是原子的，隐患就出现在这里
> ————————————————
> 原文链接：https://blog.csdn.net/qq_41572503/article/details/88775101

###### weak_ptr

```cpp
#include <iostream>    
#include <memory>    
using namespace std;    

class B;  
class A{  
public:  
    shared_ptr<B> psb;  
    ~A(){ cout << "A delete\n"; }  
};  

class B{  
public:  
    shared_ptr<A> psa;  
    ~B(){ cout << "B delete\n"; }  
};  

int main(){    
    shared_ptr<B> pb(new B());  
    shared_ptr<A> pa(new A());  
    pb->psa = pa;  
    pa->psb = pb;  
    cout << pb.use_count() << endl;  
    cout << pa.use_count() << endl;  
    return 0;  
}  
/*
输出结果：
2
2
*/
```

可以看到主函数中，pa，Pb之间相互引用，两个资源的引用计数为2，当跳出函数时，智能指针pa、pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致资源并没有释放。这就是共享指针的循环引用计数问题。

```cpp
class B{  
public:  
    weak_ptr<A> psa;  
    ~B(){ cout << "B delete\n"; }  
};  
//运行结果如下：
2
1
A delete
B delete
```

`weak_ptr `允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。

- 可打破循环引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题

###### unique_ptr

unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。**采用独占式拥有**，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

```cpp
unique_ptr<double>p1;
unique_ptr<int>p2(new (int)42);

unique_ptr<string>p1(new string("serw"));
unique_ptr<string>p2(p1);//错误：unique_ptr不支持拷贝;
unique_ptr<string>p3;
p3=p2;//错误 unique_ptr不支持赋值;
```

实现原理：我们只需要将**拷贝构造函数和赋值拷贝构造函数**申明为private或delete。

不允许拷贝构造函数和赋值操作符，但是支持==移动构造函数==，通过==std:move==把**一个对象指针变成右值之后可以移动给另一个unique_ptr，**具体做法如下

```cpp
unique_ptr<int> pInt(new int(5));  
// 转移所有权  
unique_ptr<int> pInt2 = std::move(pInt);  
```

- unique_ptr 用于取代 auto_ptr

###### auto_ptr

```
auto_ptr<string> p1 (new string ("I am jiang douya."));   
auto_ptr<string> p2;   
p2 = p1; //auto_ptr不会报错.
```

**auto**指针存在的问题是，两个智能指针同时指向一块内存，就会两次释放同一块资源，存在潜在的内存崩溃问题！因此**auto**指针被C++11弃用。应该用**unique**指针替代**auto**指针。

被 c++11 弃用，原因是缺乏**语言特性如 “针对构造和赋值” 的 `std::move` 语义，以及其他瑕疵**。

###### auto_ptr 与 unique_ptr 比较

- auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了`move` 语义；
- auto_ptr 对象不能管理数组（析构调用 `delete`），unique_ptr 可以管理数组（析构调用 `delete[]` ）；

###### std::make_unique和new的区别

std::make_unique是C++14才纳入标准库，make_unique只是把参数完美转发给要创建对象的构造函数，在从new出来的原生指针构造std::unique_ptr。

```c++
auto upw1(std::make_unique<Widget>()); // 使用make函数
std::unique_ptr<Widget> upw2(new Widget); // 不使用make函数
auto spw1(std::make_shared<Widget>()); // 使用make函数
std::shared_ptr<Widget> spw2(new Widget); // 不使用make函数
```

1. 使用new版本重复需要创建的类型，make函数不需要

   

##### 左值和右值引用

区别：

（1）左值引用是对左值的引用，右值引用是对右值的引用

const左值引用能指向右值；局限不能修改这个值

右值引用通过std::move()可以指向左值。

声明出来的左值引用或者右值引用都是左值。

（2）功能差异：

- 左值引用避免对象的拷贝(函数传参、函数返回值)
- 右值引用 ：实现移动语义，实现完美转发

移动语义：

> 对象赋值时，避免资源的重新分配
>
> 移动构造和移动拷贝构造。

完美转发：

> 函数模板可以将自己的参数完美地转发给内部调用的其他函数，完美是指不仅可以准确转发参数的值，还能保证被转发的参数的左右值属性保持不变。
>
> 借用万能引用，
>
> 引用折叠规则：参数为左值或者左值引用，T&&将转化为int&;

![image-20220904214501035](C:/Users/zzc/AppData/Roaming/Typora/typora-user-images/image-20220904214501035.png)

```std::forward<T>(v)```

> T为左值引用，v将转化为T类型的左值
>
> T为右值引用，v将转化为T类型额右值

```cpp
void func(int& n){
    cout << "lvalue = " << n << endl;
}

void func(int &&n){
    cout << "rvalue = " << n << endl;
}
template<typename T>
void revoke(T&& t){
    func(forward<T>(t));
    //func(t);
}
```

区分：

左值：可以在等号的左边，能够取地址，具名

右值：只能在等号的右边，不能取地址，不具名

纯右值：字面值，返回非引用类型的函数调用

将亡值：C++11新引入的与右值引用（移动语义）相关的值类型



```cpp
int a=9;
int b=4;

a=b;//ok;
b=a;//ok;
a=a+b;//ok;

a+b=42;//错误；a+b右值
```



##### 强制类型转换运算符

**说一说cast类型转换**

> C++为了将强制类型转换变得更加明确、控制强制转换的过程，主要将强制转换细化为四种**cast转换**方式：**const_cast**、**static_cast**、**dynamic_cast**、**reinterpret_cast**。
>
> 1. const_cast用于强制去掉不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象**必须为指针或引用。**
> 2. static_cast用于将一种数据类型强制转换为另一种数据类型。什么都可以转，**最常用。**
> 3. dynamic_cast只能用于==含有虚函数的类==转换，用于类向上和向下转换。dynamic_cast通过判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
> 4. reinterpret_cast主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。

###### static_cast

- 用于非多态类型的转换

- 不执行运行时类型检查（转换安全性不如 dynamic_cast）

- 通常用于转换数值数据类型（如 float -> int）

- 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法,**没有提供运行时检测**）

- 向上转换：指子类向基类转换。

  向下转换：指基类向子类转换。

  这两种转换，因为**子类包含父类**，子类转父类是可以任意转的。但是当父类转换成子类时可能出现非法内存访问的问题。

###### dynamic_cast

正因为static_cast从基类向子类转换时不安全，所以又引入了**dynamic_cast**。dynamic_cast只能用于含有**虚函数**的类转换，用于类向上和向下转换。只能用于具有**虚函数的基类和派生类之间的指针或引用之间的转换**，一般情况下，具有多态类类型的向下转换时必须使用，其余情况下可以不用。

dynamic_cast通过判断**变量运行时类型**和**要转换的类型**是否相同来判断是否能够进行向下转换。dynamic_cast可以做类之间上下转换，转换的时候会进行**类型检查**，类型相等成功转换，类型不等转换失败。

运用**RTTI**技术，RTTI是“Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。在c++层面主要体现在dynamic_cast和typeid，vs中虚函数表的-1位置存放了指向**type_info**的指针，对于存在虚函数的类型，dynamic_cast和typeid都会去查询type_info

1. **基类必须具有虚函数**

> 原因：dynamic_cast是运行时类型检测，需要运行时类型信息（RTTI)、而这个信息是存储与类的虚函数表关系紧密，只有一个类定义了虚函数，才会有虚函数表。

2. 运行时检查：转型不成功则返回一个空指针

3. 非必要不要使用dynamic_cast，有额外的开销。

**指针类型的dynamic_cast和引用类型的dynamic_cast的区别**

指针类型转换失败则结果为0，如果引用类型失败，则会抛出`bad_cast`异常。

###### const_cast

- 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）、但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的**指针**或**引用**的常量性，其去除常量性的对象**必须为指针或引用。**

- **常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象。**

- ```cpp
  #include <stdio.h>  
  #include <stdlib.h>  
  #include <string>  
  #include <iostream>  
  using namespace std;  
  int main() {  
      const double a = 7;  
      const double* p = &a;  
      double* q = const_cast<double*>(p);  
      *q = 20; //通过q写值是未定义的行为  
      cout << "a=" << a << endl;  
      cout << "*p=" << *p << endl;  
      cout << "*q=" << *q << endl;  
      system("Pause");      
      return 0;  
  } 
  //输出结果如下：
  a=7;
  *p=20;
  *q=20;
  ```

  可以很清楚的看到，const变量`*`p被转换为非const变量`*`q，改变`*`q的值，const变量的值均**发生了改变**。**常量指针被转化成非常量指针，并且仍然指向原来的对象**，就是这个意思。

###### reinterpret_cast

- 用于位的简单重新解释

- **编译期处理，执行的是逐字节复制的操作**，类似于C语言里面的强转

- 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。

- 允许将任何指针转换为任何其他指针类型（如 `char*` 到 `int*` 或 `One_class*` 到 `Unrelated_class*` 之类的转换，但其本身并不安全）

- 也允许将任何整数类型转换为任何指针类型以及反向转换。

- reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。

- reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。

- 在C++语言中，reinterpret_cast主要有三种强制转换用途：

  （1）改变指针或引用的类型

  （2）将指针或引用转换为一个足够长度的整形

  （3）将整型转换为指针或引用类型。如下：

  ```c++
  int p1 = 1;  
  int* p2 = reinterpret_cast<int*>(p1);  
  int* p2 = (int*)p1;  
  int p3 = reinterpret_cast<int>(p2);  
  ```

###### bad_cast

- 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。

```c++
try {  
    Circle& ref_circle = dynamic_cast<Circle&>(ref_shape);   
}  
catch (bad_cast b) {  
    cout << "Caught: " << b.what();  
} 
```

##### 运行时类型信息 (RTTI)

RTTI机制：

运行时类型识别，比如运行时，要根据用户的输入选择父类指针的指向，输入小于100指针指向父类函数，大于等于100指向子类函数。在C++中，只有类中包含了虚函数时才会启用RTTI机制，其他所有情况都可以在编译阶段确定类型信息。

###### dynamic_cast

- 用于多态类型的转换

###### typeid

- typeid 运算符允许在运行时确定对象的类型
- type_id 返回一个 type_info 对象的引用
- 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数
- 只能获取对象的实际类型

###### type_info

- type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。
- 头文件：`typeinfo`

**typeid、type_info 使用**

```c++
#include <iostream>
using namespace std;

class Flyable                       // 能飞的
{
public:
    virtual void takeoff() = 0;     // 起飞
    virtual void land() = 0;        // 降落
};
class Bird : public Flyable         // 鸟
{
public:
    void foraging() {...}           // 觅食
    virtual void takeoff() {...}
    virtual void land() {...}
    virtual ~Bird(){}
};
class Plane : public Flyable        // 飞机
{
public:
    void carry() {...}              // 运输
    virtual void takeoff() {...}
    virtual void land() {...}
};

class type_info
{
public:
    const char* name() const;
    bool operator == (const type_info & rhs) const;
    bool operator != (const type_info & rhs) const;
    int before(const type_info & rhs) const;
    virtual ~type_info();
private:
    ...
};

void doSomething(Flyable *obj)                 // 做些事情
{
    obj->takeoff();

    cout << typeid(*obj).name() << endl;        // 输出传入对象类型（"class Bird" or "class Plane"）

    if(typeid(*obj) == typeid(Bird))            // 判断对象类型
    {
        Bird *bird = dynamic_cast<Bird *>(obj); // 对象转化
        bird->foraging();
    }

    obj->land();
}

int main(){
	Bird *b = new Bird();
	doSomething(b);
	delete b;
	b = nullptr;
	return 0;
}
```

##### 指针与引用的区别

> - 指针是变量，这个变量存放的是所指内容的**地址**。引用是**别名**，与所引用变量占用同一内存空间。
> - 指针可以是空，可以在任何时候初始化，但是引用的值不能为空，在定义时必须得初始化。
> - 指针的值在**初始化后可以改变**，但是引用在**初始化之后就不可以改变**了。
> - ”sizeof引用”得到的是所指向的**变量(对象)的大小**，而”sizeof指针”得到 的是**指针本身的大小**
> - 如果返回的是动态分配的内存或对象，必须使用指针，使用引用会产生内存泄漏
> - 指针可以有多级，但是引用只能是一级
> - 对引用的操作即是对变量本身的操作。
> - 不能有NULL引用，引用必须与一块合法的存储单元关联。
> - 指针和引用的自增(++)运算意义不一样；

##### **字节对齐**

1. **什么是内存对齐**？

那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，**编译器为结构体的每个成员按其自然边界（alignment）分配空间。**各个成员按照它们被声明的顺序在内存中顺序存储，**第一个成员的地址和整个结构体的地址相同**。

![img](https://i.loli.net/2021/04/11/r1oVXlcnwgQ5qdm.png)

为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的“对齐”，比如4字节的int型，其**起始地址**应该位于4字节的边界上，即**起始地址能够被4整除**，也即“对齐”跟数据在内存中的位置有关。==如果一个变量的内存地址正好位于它长度的整数倍，他就被称做**自然对齐**==。

**为什么要字节对齐？**

需要字节对齐的根本原因在于CPU访问数据的**效率问题**。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。

```c
union example {  
    int a[5];  
    char b;  
    double c;  
};  
int result = sizeof(example);  
```

**union中变量共用内存，而且以最长的为准**，所以最长的是`int a[5]（5*4=20Byte）`，那么最终`result=20`？

**共用体这里需要满足一个原则**：**占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍。**

满足整除double（8Byte）同时又可以容纳`int a[5]`的大小，所以正确的结果应该是result=24。

```cpp
#include<iostream>
using namespace std;

struct example {  
    int a[5];  
    char b;  
    double c;  
}test_struct;
int main(){
    int result = sizeof(test_struct);  
    cout<<result<<endl;
}
//输出32；
```

![img](https://i.loli.net/2021/04/11/GWTNYL3rMe5hmOx.png)

```cpp
struct example {  
    char b;  
    double c;  
    int a;  
}test_struct;  
int result = sizeof(test_struct);
```

对于结构体字节对齐除了**内存起始地址要是数据类型的整数倍**以外，还要满足一个条件，那就是**占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍**，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24

##### **强制对齐**pragma pack(n)

设定结构体、联合以及类成员变量以 n 字节方式对齐

pragma pack(n) 使用

```c++
#include <stdio.h>  
#include <stdlib.h>  
#include <iostream>  

#pragma pack(push)  // 保存对齐状态
#pragma pack(4)     // 设定为 4 字节对齐;结构体成员所占用内存的起始地址需要是n的整数倍
using namespace std;  

struct example{  
    char a;  
    double b;  
    int c;  
}test_struct;  
#pragma pack(pop)   // 恢复对齐状态

int main() {  
    int result = sizeof(test_struct);  
    cout << result << endl;  
//    system("Pause");  
    return 0;  
}  
//result=16;


#pragma pack(4)  
struct example{  
    char a;  
    double b;  
    char c;  
}test_struct;  
//内存大小为:16;

#pragma pack(4)  
using namespace std;  
struct example{  
    int a;  
    char b;  
    short int c;  //short int 内存大小为2个字节，整数倍这里自然对齐为6;
    char d;  
}test_struct;
//内存大小为12

#pragma pack(8)  
using namespace std;  
struct example{  
    int a;  
    char b;  
    short int c;  
    int d;  
}test_struct;  
//内存大小为12字节;
```

\#pragma pack(n)表示，我们结构体成员所占用内存的**起始地址**需要是n的整数倍。这里n是4。所以就需要填充一定的字节数，规定：

**对齐字节数 = min（成员起始地址应是n的倍数时填充的字节数， 自然对齐时填充的字节数）**。

**总结：**可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来指定我们的对齐系数，其中的n就是我们要指定的“对齐系数”。

规则一：对齐字节数 = min（成员起始地址应是n的倍数时填充的字节数， 自然对齐时填充的字节数）。

规则二：同时满足占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍。

如果想要取消结构体对齐:加入`__attribute__((packed))`

```cpp
#include <stdio.h>  
#include <stdlib.h>  
#include <iostream>  
using namespace std;  
struct {  
    char b;  
    double c;  
    int a;  
}__attribute__((packed)) test_struct;  
int main() {  
    int result = sizeof(test_struct);  
    cout << result << endl;  
    return 0;  
}  
```

答案是13，说明这个时候取消了字节对齐。我们只要定义结构体时加上`__attribute__((packed))`就可以

##### 堆和栈的区别

> 1. 管理方式不同
>
> 栈，由编译器自动管理，无需程序员手工控制，栈区内存由系统**自动**分配，函数结束时释放；堆：产生和释放由程序员控制，并指明大小，用户忘释放时，会造成内存泄露，不过进程结束时会由系统回收。。
>
> 2. 空间大小不同
>
> 栈的空间有限；栈是1或者2M，可以自己改，但是最大不超过8M；堆，看主机是多少位的，如果是32位，就是4G；
>
> 3. 能否产生碎片不同
>
> 栈不会产生碎片，因为栈是种先进后出。堆则容易产生碎片，多次的new/delete会造成内存的不连续，从而造成大量的碎片。
>
> 4. 生长方向不同
>
> ==堆的生长方式是向上的，像高地址方向增长==；==栈是向下的，想低地址方向增长==。
>
> 5. 分配方式不同
>
> 堆是动态分配的。栈可以是静态分配和动态分配两种，静态分配由编译器完成（如函数局部变量），动态分配由malloc函数分配，但栈的动态分配资源由编译器自动释放，无需程序员实现
>
> 6. 分配效率不同
>
> 栈是机器系统提供的数据结构，计算机底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令。堆则是由C/C++函数库提供，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。
>
> 堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家 尽量用栈，而不是用堆。
>
> 栈和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。



> 栈区和堆区的区别：
>
> 1)申请方式： 栈区内存由系统**自动**分配，函数结束时释放；堆区内存由**程序员**自己申请，并指明大小，用户忘释放时，会造成内存泄露，不过进程结束时会由系统回收。
>
> 2)申请后系统的响应： 只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示**栈溢出**；堆区，**空闲链表**，分配与回收机制，会产生碎片问题（外部碎片）-->（固定分区存在内部碎片（分配大于实际），可变分区存在外部碎片（太碎无法分配））。
>
> 3)申请大小的限制：栈是1或者2M，可以自己改，**但是最大不超过8M**；堆，看主机是多少位的，如果是32位，就是4G
>
> 4)申请效率：栈由系统自动分配，速度较快，程序员无法控制；堆是由new分配的内存，一般速度较慢，而且容易导致内存碎片，但是用起来方便！
>
> 5)存储内内容：栈，函数调用（返回值，各个参数，局部变量（**静态变量不入栈**））；堆，一般在堆的头部用一个字节存放堆的大小，堆中的具体内容由程序员安排。
>
> 6)存取效率的比较：栈比堆快，Eg :char c[] = /"1234567890/";char *p =/"1234567890/";读取c[1]和p[1],c[1]读取时直接吧字符串中的元素读到寄存器cl中，而p[1]先把指针值读到edx中，再根据edx读取字符，多一次操作。
>
> 7)管理方式不同：栈，数据结构中的栈；堆，链表
>
> 8)生长方向：栈，高到低；堆，低到高

##### 内存

![这里写图片描述](https://i.loli.net/2021/04/30/UQvouXPpjeqlz3Z.png)

![image-20220330224555549](https://s2.loli.net/2022/03/30/qIBxU1r3KpnO49i.png)

**代码区（text segement)**：存放程序的代码，存放函数体（类成员函数和全局函数）的二进制代码，即CPU执行的机器指令，并且是只读的，有些立即数。==虚函数位于.text代码段==，

**常量区**（.rodata段)：存放常量(程序在运行的期间不能够被改变的量，例如: 10，字符串常量”abcde”， 数组的名字等)，程序结束后由系统释放，const全局变量、#define定义的常量，==虚函数表也在这个区域==

**静态区**（.bss段和.data段）（全局区）：静态变量和全局变量的存储区域是一起的，一旦静态区的内存被分配, 静态区的内存直到程序全部结束之后才会被释放

> `.bss段`:未初始化的全局变量，或者默认为0的全局变量，属于静态内存分配；
>
> `.data段`: 已经初始化的全局变量，static 声明的变量。

**堆区**：由程序员调用malloc()函数来主动申请的，需使用free()函数来释放内存，若申请了堆区内存，之后忘记释放内存，很容易造成内存泄漏。

**栈区**：存放函数内的**局部变量，形参和函数返回值**。栈区之中的数据的作用范围过了之后，系统就会回收自动管理栈区的内存(分配内存 , 回收内存),不需要开发人员来手动管理。

堆和栈的增长方向：堆由低地址向高地址；栈是由高地址向低地址；

**带有虚函数的内存布局**

![image-20220330225957742](https://s2.loli.net/2022/03/30/TSMsu96HkRfEzFi.png)

##### 内存泄漏问题

![image-20220320175500513](https://s2.loli.net/2022/03/20/sj4IvxZk2VQJoCp.png)

1、当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露；

```cpp
#include <iostream>
using namespace std;
class A {
public:
	A() {
		cout << "A constru" << endl;
	}
	~A() {
		cout << "A desconstructor" << endl;
	}
};


class B :public A {
public:
	B() {
		cout << "B constr" << endl;
	}
	~B() {
		cout << " B des" << endl;
	}
};

int main()
{
	A *a = new B();
	delete a;
	return 0;
}
//输出结果：
A constru
B constr
A desconstructor
//如果将父类析构函数声明为虚函数：
A constru
B constr
B des
A desconstructor
    
int main()
{
	//A *a = new B();
	B *b = new B();
	//delete a;
	delete b;
	return 0;
}
//派生类指针指向派生类对象，会自动调用父类的构造函数和析构函数；
```

2、**在类的构造函数和析构函数中没有匹配的调用new和delete函数**

3、**在释放对象数组时在delete中没有使用方括号**

4、 **缺少拷贝构造函数**

> 两次释放相同的内存是一种错误的做法，同时可能会造成堆的崩溃。
>
> 按值传递会调用（拷贝）构造函数，引用传递不会调用。
>
> 在C++中，如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针。当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间。而释放第二个对象的时候，它的析构函数会释放相同的内存，这样是错误的。
>
> **所以，如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符**

##### 内存分配和管理

**malloc、calloc、realloc、alloca**

> 1. malloc：申请指定**字节数的内存。申请到的内存中的初始值不确定。**
> 2. calloc：**为指定长度的对象**，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。
> 3. realloc：**更改以前分配的内存长度（增加或减少）**。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而**新增区域内的初始值则不确定。**
> 4. alloca：**在栈上申请内存**。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。

###### malloc、free

**用于分配、释放内存**

malloc、free 使用

申请内存，确认是否申请成功

```
char *str = (char*) malloc(100);
assert(str != nullptr);
```

释放内存后指针置空

```
free(p); 
p = nullptr;
```

###### new、delete

1. new / new[]：完成两件事，先**底层调用 malloc 分配了内存，然后调用构造函数（创建对象）**。
2. delete/delete[]：也完成两件事，先**调用析构函数（清理资源），然后底层调用 free 释放空间。**
3. new 在**申请内存时会自动计算所需字节数**，而 malloc 则需我们**自己输入申请内存空间的字节数**。

**new、delete 使用**

申请内存，确认是否申请成功

```c++
int main()
{
    T* t = new T();     // 先内存分配 ，再构造函数
    delete t;           // 先析构函数，再内存释放
    return 0;
}
```

动态分配一个const对象；

一个动态分配的const对象必须进行初始化，由于分配的对象是const，new返回的指针是一个指向const的指针；

```cpp
const  int *pci=new const int(1024);
delete pci;
```

delete之后重置指针值；

> 当我们delete一个指针后，指针值就变得无效，指针变为==悬空指针==，即指向一块曾经保存数据对象但现在已经无效的内存的指针；

接受指针参数的智能指针构造函数是explicit的，==不能将一个内置指针隐式转换为一个智能指针==，必须使用直接初始化。

```cpp
shared_ptr<int>p1=new int(1024);//错误，必须使用直接初始化形式;
shared_ptr<int>p2(new int(1024));//正确，使用了直接初始化形式；
//错误
shared_ptr<int>clone(int p){
	return new int(p);
}
//正确;
shared_ptr<int>clone(int p){
    return shared_ptr<int>(new int(p));
}
```

###### **malloc底层实现及原理**

[malloc实现原理]: https://www.cnblogs.com/zpcoding/p/10808969.html#_labelTop

1）当开辟的空间小于 128K 时，调用 brk（）函数，malloc 的底层实现是**系统调用函数 brk（）**，其主要移动指针 _enddata(此时的 _enddata 指的是 Linux 地址空间中堆段的末尾地址，不是数据段的末尾地址)

2）当开辟的空间大于 128K 时，mmap（）系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟。

默认情况下，**malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存**

**这样做主要是因为:**

　　**brk**分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，因为只有一个_edata 指针，这就是内存碎片产生的原因，什么时候**紧缩**看下面），而mmap分配的内存可以单独释放。

　		事实是：_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。**也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。**

###### 定位 new

默认的new操作是从堆区申请空间，定位new即可在栈上生成对象，也可以在堆上生成对象，也可以是静态存储区，好处是不用频繁的申请和释放空间，造成系统大量内存碎片.

定位 new（placement new）允许我们向 new 传递额外的地址参数，**从而在预先指定的内存区域创建对象**。

```cpp
new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_address) type [size] { braced initializer list }

A* p = new(ptr)A;
//ptr就是程序员指定的内存地址
//指针p和ptr指向同一片存储区，定位new，是利用已经申请好的空间，真正空间的在之前完成的

//定位生成对象时，会自动调用类A的构造函数，但是由于对象的空间不会自动释放(对象实际上是借用别人的空间)，所以必须显示调用类的析构函数，
```

- `place_address` 是个指针
- `initializers` 提供一个（可能为空的）以逗号分隔的初始值列表

##### 如何优化brk减少频繁的系统调用？（JeMalloc,tcMalloc,ptMalloc）

> 频繁调用还会产生内存碎片，malloc采用内存池的管理方式（ptmalloc），ptmalloc 采用边界标记法将内存划分成很多块，从而对内存的分配与回收进行管理。为了保证内存分配的高效性，ptmalloc会预先向操作系统申请一块内存，当申请/释放内存时，ptmalloc会将这些内存管理起来，并通过一些策略来判断是否将其回收给操作系统。这样做的最大好处就是，使内存的申请/释放更为高效，避免产生过多的内存碎片

###### delete this 合法吗？

合法，但：

1. 必须保证 this 对象是通过 `new`（不是 `new[]`、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的
2. 必须保证调用 `delete this` 的成员函数是最后一个调用 this 的成员函数
3. 必须保证成员函数的 `delete this `后面没有调用 this 了
4. 必须保证 `delete this` 后没有人使用了

##### 如何定义一个只能在堆上（栈上）生成对象的类？

###### 只能在堆上

方法：将**析构函数设置为私有**

原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。**若析构函数不可访问，则不能在栈上创建对象。**

类对象只能建立在堆上，就是==不能静态建立类对象==，即不能直接调用类的构造函数。

容易想到将构造函数设为私有。在构造函数私有之后，无法在类外部调用构造函数来构造类对象，只能使用new运算符来建立对象。然而，前面已经说过，new运算符的执行过程分为两步，C++提供new运算符的重载，其实是只允许重载operator new()函数，而operator()函数用于分配内存，无法提供构造功能。因此，这种方法不可以。

当对象建立在栈上面时，是由编译器分配内存空间的，调用构造函数来构造栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器管理了对象的整个生命周期。如果编译器无法调用类的析构函数，情况会是怎样的呢？比如，类的析构函数是私有的，编译器无法调用析构函数来释放内存。所以，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。

 试着使用A a;来建立对象，编译报错，提示析构函数无法访问。这样就只能使用new操作符来建立对象，构造函数是公有的，可以直接调用。==类中必须提供一个destory函数，来进行内存空间的释放==。类对象使用完成后，必须调用destory函数。

上述方法的一个缺点就是，无法解决继承问题。如果A作为其它类的基类，则析构函数通常要设为virtual，然后在子类重写，以实现多态。因此析构函数不能设为private。还好C++提供了第三种访问控制，protected。==将析构函数设为protected可以有效解决这个问题，类外无法访问protected成员，子类则可以访问==。

另一个问题是，类的使用很不方便，使用new建立对象，却使用destory函数释放对象，而不是使用delete。（使用delete会报错，因为delete对象的指针，会调用对象的析构函数，而析构函数类外不可访问）这种使用方式比较怪异。为了统一，可以将**构造函数设为protected**，然后提供一个**public的static函数来完成构造**，这样不使用new，而是使用一个函数来构造，使用一个函数来析构，类似于单列模式。

###### 只能在栈上

方法：将 new 和 delete 重载为私有

原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段**：第一阶段，使用 new 在堆上寻找可用内存，分配给对象**；**第二阶段，调用构造函数生成对象**。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。

##### static关键字

**（1）定义静态函数或全局变量**

当我们同时编译多个文件时，在函数返回类型或全局变量前加上static关键字，函数或全局变量即被定义为静态函数或静态全局变量。静态函数或静态全局变量只能在本源文件中使用。这就是static的**隐藏属性**。

```c++
// #include "myStatic.h"
static void func(); // 那么此时func函数被限定在myStatic.c文件才能使用
// extern void func(); // 若是要扩展出去，需要使用extern关键字
```

**（2）static 的第二个作用是保持变量内容的持久**

在变量前面加上static关键字。初始化的静态变量会在**数据段**分配内存，未初始化的静态变量会在**BSS段**（通常用来存放程序中未初始化的全局变量的一块内存区域，静态内存分配）分配内存。直到程序结束，静态变量始终会维持当前值。只不过全局静态变量和局部静态变量的作用域不一样。

```cpp
void func(void){ 
    static int a = 10;// 这里要注意，a是静态变量，函数func调用完成后，a并不会销毁，而是保持直到程序结束运行。
    int b = 10; // b是局部变量，函数调用完成后销毁。
}
```

（3）**static 的第三个作用是默认初始化为 0**：**全局变量**也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是 **0x00**，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置 **0**，然后把不是 **0** 的几个元素赋值。如果定义成静态的，就省去了一开始置 **0** 的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加 **\0** 太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是 **\0** 。

**（4）类中的静态成员变量**

我们有时候需要为某个类的所有对象分配一个单一的存储空间。我们当然可以使用全局变量，但这样不安全。全局数据可以被任何人修改，也容易和其他变量名冲突。在C++中，我们就可以使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而**不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块静态存储空间**；

C++静态数据成员被类的所有对象所共享，包括**该类的派生类的对象**。而静态数据成员在内存中只占一份空间。如果改变了它的值，则对应的所有对象中该数据成员的值都发生了改变；

**（5）类中静态成员函数**

如果要在类外调用公用的静态成员函数，要用类名和域运算名“：：”，如`Box::volume();` 实际上也允许通过对象名调用静态成员函数，如：`a.volume();`但这并不意味着此函数属于对象`a`的，而只是用`a`的类型而已。

**静态成员函数也是类的一部分，而不是对象的一部分**

与静态成员变量不同，==静态成员函数的作用不是为了对象之间的沟通，而是为了能处理静态成员变量==；

当调用一个对象的非静态成员函数时，系统会把**该对象的起始地址赋给成员函数的this指针**。而静态成员函数不属于任何一个对象，因此**C++规定静态成员函数没有this指针**。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。

静态成员函数可以直接引用本类中的静态成员变量。**在C++中，静态成员函数主要用来访问静态成员变量，而不访问非静态成员变量**。养成良好习惯，这样编程思路更清晰、逻辑更清楚。

```cpp
#include <iostream>  
using namespace std;  
class Sprout{//声明豆芽类  
public:  
    Sprout(int a, int m):age(a),money(m){}  
    void total();  
    static double average();  
private:  
    int age;  
    int money;  
    static int count;//声明两个静态成员变量，所有对象共享  
    static int sum;  
};  
//static关键字只能用于类定义体内部的声明中，定义时不能标示为static
int Sprout::count = 0;//定义静态成员变量 静态成员变量必须在类外初始化; 
int Sprout::sum = 0;  
void Sprout::total(){//定义非静态成员函数  
    sum += money;//非静态成员函数中可以使用静态成员变量、非静态成员变量  
    count++;  
}  
double Sprout::average(){//定义静态成员函数  
    return sum*1.0/count;//静态成员函数中可以引用静态成员变量，不用加类名  
}  
int main(){  
    Sprout sprout1(45, 99);  
    sprout1.total();//调用类的非静态成员函数  
    Sprout sprout2(36, 109);  
    sprout2.total();  
    Sprout sprout3(38, 79);  
    sprout3.total();  
    cout << Sprout::average() << endl;//调用类的静态成员函数，输出结果95.67  
    return 0;  
}  
```



##### const关键字

**C++中的const机制类似C语言中的宏，都是替换，不过C++的const是在编译阶段替换，C语言的宏是在预编译阶段替换**。

https://blog.csdn.net/ypshowm/article/details/89030156

意味着“可读”

> 1）欲阻止一个变量被改变，可使用const，在定义该const变量时，需先初始化，以后就没有机会改变他了；
>
> 2）对指针而言，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
>
> 3）在一个函数声明中，const可以修饰==形参==表明他是一个输入参数，==在函数内部不可以改变其值==；
>
> 4）对于类的成员函数，有时候必须指定其为const类型，表明其是一个==常函数，不能修改类的成员变量==；
>
> 5）对于类的成员函数，有时候必须指定其==返回值为const类型==，以使得其返回值不为“左值”。

**const修饰变量**

- 变量的值不能改变

**const修饰指针**

```c++
int a,b;
const int a;int const a;//这两者意义相同
const int *p=&a;//常量指针，*p不可变，是常量，即指针指向的值是常量，指针可变
int *const p=&a;//指针常量，指针变量是常量，不可修改，但是指针指向的值可以改变
```

- 如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量
- 如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量，防止改变指针指向的位置；

**函数中使用const**

- const修饰函数参数
  - 表示参数不可变
    - 若参数为引用，可以增加效率
      - const引用传递和函数按值传递的效果是一样的，但按值传递会先建立一个类对象的副本, 然后传递过去**,而它直接传递地址,所以这种传递比按值传递更有效**
      - const按值传递时只是外部对象的拷贝，值的改变不会对外部有什么影响，那么是不是没有什么意义：错，重要的目的就是告诉说这个变量不允许被修改，传引用效率会高一点而已。
      - **值传递时，实参会被复制一份为形参，形参在函数体内不论如何改变都不会影响实参的值，那么自然没必要加const了。只有当我们传递引用或指针时才需要考虑是否加const**

**类中使用const**

- const修饰成员变量
  - 表示成员变量不能被修改，**同时只能在初始化列表中赋值**
- const修饰成员函数
  - 该函数不能改变对象的成员变量；**const 修饰类成员函数**，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。
  - **不能调用非const成员函数**，因为任何非const成员函数会有修改成员变量的企图
  - **const的成员函数才能被一个const类对象调用。即const类对象只能调用const成员函数**
  - **const关键字不能与static关键字同时使用**，因为static关键字修饰静态成员函数，静态成员函数不含有this指针，即不能实例化，const成员函数必须具体到某一实例。
- const修饰类对象
  - 对象的任何成员都不能被修改
  - 只能调用const成员函数

```c++
// 类
class A
{
private:
    const int a;                // 常对象成员，只能在初始化列表赋值

public:
    // 构造函数
    A() : a(0) { };
    A(int x) : a(x) { };        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function()
{
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数、更新常成员变量
    const A a;                  // 常对象，只能调用常成员函数
    const A *p = &a;            // 指针变量，指向常对象
    const A &q = a;             // 指向常对象的引用

    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量
}

// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char* Var);         // 参数指针所指内容为常量
void function3(char* const Var);         // 参数指针为常量
void function4(const int& Var);          // 引用参数在函数内为常量

// 函数返回值
const int function5();      // 返回一个常数
const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();
int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();
```

##### **const和constexpr**

```c++
#include <iostream>  
#include <array>  
using namespace std;  
void test_1(const int x) {  
    //错误，x是只读的变量  
    array <int, x> myarr{ 1,2,3,4,5 };  
    cout << myarr[1] << endl;  
}  
void test_2() {  
    const int x = 5;  
    array <int, x> myarr{ 1,2,3,4,5 };  
    cout << myarr[1] << endl;  
}  
int main() {  
    test_1(5);  
    test_2();  
}  
```

`test_1()`和`test_2()`函数中都包含一个 `const int x`，但`test_1()`函数中的`x`无法完成初始化array容器的任务，而`test_2()`函数中的`x`却可以。

这是因为，`test_1()`函数中的`“const int x”`只是想强调`x`是一个只读的变量，**其本质仍为变量**，无法用来初始化array容器；而`test_2()`函数中的`“const int x”`，表明`x`是一个只读变量的同时，`x`还是一个值为5的**常量**，所以可以用来初始化array容器.

C++11标准中，为了解决const关键字的双重语义问题，C++11保留了const表示“只读”的语义，而将“常量”的语义划分给了新添加的**constexpr**关键字。

因此C++11标准中，建议将const和constexpr的功能区分开，**即凡是表达“只读”语义的场景都使用const，表达“常量”语义的场景都使用constexpr**。在上面的实例程序中，`test_2()`函数中使用`const int x`是不规范的，应使用`constexpr`关键字

##### staic和const以及static const初始化

```cpp
	const定义的常量在超出其作用域之后其余空间会被释放；而static定义的静态常量在函数执行后不会释放其存储空间。
	static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。
	在C++中，static静态成员变量不能在类的内部初始化即不能通过构造函数初始化。因为在整个程序运行过程中只有一个副本，在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate=2.25;static关键字只能用于类定义体内部的声明中，定义时不能标示为static;静态数据成员是类的成员而不是对象的成员;
	在C++中，const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。
	const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，而对象内部const修饰的变量可能值是不一样的；所以不能再类的声明中初始化const数据成员。
	const数据成员的初始化只能在类的构造函数初始化列表中进行，要想建立在整个类中都恒定的常量应用类中枚举常量来实现，或者staic const;
	const成员函数主要目的是防止成员函数修改对象的内容，即const成员函数不能修改成员变量的值，但可以访问成员变量。
	static成员函数主要目的是作为类作用域的全局函数，不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致：1、不能直接存取类的非静态成员变量，调用非静态成员virtual;2，不能与const关键字一起使用修饰成员函数；
	
```

```cpp
#include<iostream>
using namespace std;

class Test{
public:
    Test(int val);//常量成员变量初始化
//    Test(int val):a(val){} //常量成员变量初始化
    enum{size1=100,size2=200};
    static void print();
private:
    const int a;//只能在构造函数初始化列表中初始化
    static int b;//在类的实现文件中定义和初始化
    const static int c;//与static const int c相同;一个是常量静态，一个是静态常量，静态都储存在全局变量区；
};
Test::Test(int val):a(val){
    b+=1;
}
int Test::b=0;//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象;前面也不能加static
const int Test::c=0;//注意：给静态常量成员变量赋值时，不需要加static关键字，但要加const;
void Test::print(){
    cout<<"b="<<b<<endl;
    cout<<"c="<<c<<endl;
}

int main(){
    Test t1(10);
    t1.print();//通过对象访问静态成员函数
    Test::print();//通过类直接访问静态成员函数
    return 0;
}

//111.cpp
#include<iostream>
using namespace std;
class Test{
public:
    const int b=3;
    static const int i=3;
   /* static  void fun() const{
        cout<<"hello";
    }*/ //error 错误 静态成员函数没有this指针，而const初始化需要实例化对象；
};
//const int  Test::i=2;
int main(){
    cout<<Test::i<<endl;
  //  Test::fun();
    int a=3;
    const int *p= &a;
    int *const m=&a;
    *m=4;
   // *p=4;(错误，常量指针，指针所指向的值不能改变，只读（readonly)
    cout<<*p<<endl;
    cout<<*m<<endl;
    return 0;
}


```

##### Final关键字

c++中的final关键字用来修饰函数，防止这个函数被子类重写。

##### Virtual和override关键字

1. 提示读者此函数重写了基类虚函数（表示这个函数是从基类继承）；
2. 强制编译器检查此函数定义是否重写基类虚函数；

##### volatile关键字

```c++
volatile int i = 10; 
```

- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
- volatile 关键字声明的变量，**每次访问时都必须从内存中取出值**（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
- const 可以是 volatile （如只读的状态寄存器）
- 指针可以是 volatile

volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。volatile 提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会**直接从变量地址中读取数据**。

如果没有 volatile 关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。遇到这个关键字声明的变量，**编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问**。声明时语法：**int volatile vInt;** **当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据**，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。

用途：

- 1) 中断服务程序中修改的供其它程序检测的变量需要加 volatile；
- 2) 多任务环境下各任务间共享的变量应该加 volatile；
- 3) 存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义。如并行设备的硬件寄存器。

**多线程下的volatile**

当两个线程都要用到某一个变量且该变量的值会被改变时，应该用 volatile 声明，**该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中**。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是**让编译器每次操作该变量时一定要从内存中真正取出**，而不是使用已经存在寄存器中的值，如下

**1、一个参数既可以是const还可以是volatile吗？**

可以，例如**只读的状态寄存器**。它是 volatile 因为它可能被意想不到地改变。它是 const 因为 程序不应该试图去修改它。

**2、一个指针可以是 volatile 吗？**

可以，当一个中断服务子程序修改一个指向一个 buffer 的指针时。



##### 深拷贝与浅拷贝

C++中类的拷贝有两种：深拷贝，浅拷贝：当出现类的等号赋值时，即会调用拷贝函数
一：两个的区别
1  在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，**如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象**，所以，此时，必须采用深拷贝。
2 **深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。**
二  带实例的解释
**c++默认的拷贝构造函数是浅拷贝**
浅拷贝就是对象的数据成员之间的简单赋值，如你设计了一个没有类而没有提供它的复制构造函数，当用该类的一个对象去给令一个对象赋值时所执行的过程就是浅拷贝，如：

```cpp
class A 
{ 
	public: 
	A(int _data) : data(_data){} 
	A(){}
	private: 
	int data;
 };
int main() 
{ 
	A a(5), b = a; // 仅仅是数据成员之间的赋值 
}
```

这一句b = a;就是浅拷贝，**执行完这句后b.data = 5;**
**如果对象中没有其他的资源（如：堆，文件，系统资源等），则深拷贝和浅拷贝没有什么区别，**
但当对象中有这些资源时，例子：

```cpp
class A 
{ 
	public: 
	A(int _size) : size(_size)
	{
		data = new int[size];
	} // 假如其中有一段动态分配的内存 
	A(){};
	 ~A()
	{
		delete [] data;
	} // 析构时释放资源
	private: 
	int* data;
	int size; 
}
int main() 
{ 
	A a(5), b = a; // 注意这一句 
}
```



这里的b = a会造成未定义行为，因为类A中的复制构造函数是编译器生成的，所以b = a执行的是一个浅拷贝过程。我说过浅拷贝是对象数据之间的简单赋值，比如：
b.size = a.size;
b.data = a.data; // Oops!
这里b的指针data和a的指针指向了堆上的同一块内存，a和b析构时，b先把其data指向的动态分配的内存释放了一次，而后a析构时又将这块已经被释放过的内存再释放一次。对同一块动态内存执行2次以上释放的结果是未定义的，所以这将导致内存泄露或程序崩溃。
所以这里就需要深拷贝来解决这个问题，**深拷贝指的就是当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值**。如：

```cppclass A 
{ 
	public: 
	A(int _size) : size(_size)
	{
		data = new int[size];
	} // 假如其中有一段动态分配的内存 
	A(){};
```

```cpp
```



​	A(const A& _A) : size(_A.size)`
​	`{`
​		`data = new int[size];`
​	} // 深拷贝` 



​	~A()
​	{
​		delete [] data;
​	} // 析构时释放资源
​	private: 
​	int* data; 
 	int size;
 }
int main() 
{ 
​	A a(5), b = a; // 这次就没问题了 
}



总结：深拷贝和浅拷贝的区别是在对象状态中包含其它对象的引用的时候，当拷贝一个对象时，如果需要拷贝这个对象引用的对象，则是深拷贝，否则是浅拷贝。

##### assert

断言，是宏，而非函数。assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。

assert() 使用

```c++
#define NDEBUG          // 加上这行，则 assert 不可用
#include <assert.h>

assert( p != NULL );    // assert 不可用
```

##### sizeof和strlen的区别

- sizeof(...)是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、**类型、对象、函数**等。
- 它的功能是：获得保证能容纳实现所建立的最大对象的字节大小；
- 由于在编译时计算，因此sizeof不能用来返回动态分配的内存空间的大小。实际上，用sizeof来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。

**strlen:**

-   strlen(...)是函数，要在运行时才能计算。参数必须是字符型指针（char*）。当数组名作为参数传入时，实际上数组就退化成指针了。
- 它的功能是：返回字符串的长度。

```cpp
char *ss="0123456789";
sizeof(ss) //指针为4；
sizeof(*ss) //结果为1;第一个字符，char类型为一个字节;
strlen(ss)=10;//字符串的长度;为10;
```

##### lambda表达式

在编程过程中，我们经常定义一些只会调用一次的函数，引入拉姆达表达式用于定义和创建匿名对象。

Lambda表达式的语法形式如下：

```c++
[函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -> 返回值类型 {函数体}  
```

1. **[函数对象参数]**

函数对象参数标识一个 Lambda 表达式的开始，这部分不能省略。方括号 [] 内的参数集合叫做一个**闭包**，允许Lambda 函数可以引用在它之外声明的变量，这个机制允许这些变量被按值或按引用**捕获**;

2.**(操作符重载函数参数)**

标识重载的 () 操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如: (a, b)）和按引用 (如: (&a, &b)) 两种方式进行传递。

3.**mutable 或 exception 声明override**

这部分可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改传递进来的拷贝（注意是能修改拷贝，而不是值本身）。exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int)。

4.**返回值类型**

标识函数返回值的类型

5.**{函数体}**

标识函数的实现，这部分不能省略，但函数体可以为空；

实例：

```cpp
[] (int x, int y) { return x + y; } // 隐式返回类型  
[] (int& x) { ++x; } //没有return语句，Lambda函数的返回类型是void
[] () { ++global_x; } //没有参数，仅访问某个全局变量  
[] { ++global_x; } //与上一个相同，省略了(操作符重载函数参数)  
[] (int x, int y)->int{ int z = x+y; return z; }//可以指定返回类型  
auto cmp = [](int x, int y){ return x > y; } //匿名函数也可以有名称 
```

```cpp
#include <bits/stdc++.h>  
using namespace std;  

int main(){  
    vector<int> alist;  
    int total = 0;  
    for (int i=0; i<5; ++i)   
        alist.push_back(i);  
    //指定倒序排序  
    auto cmp = [](int a, int b){return a>b;};  
    sort(alist.begin(),alist.end(),cmp);  
    for (int i=0; i<alist.size(); ++i)  
        cout << alist[i] << endl;  
} 
```

**lambda实现原理是什么？**

> 编译器会把一个lambda表达式生成一个匿名类的匿名对象，并在类中**重载**函数调用运算符`()`。

**参数捕获**

lambda有个特殊的功能，Lambda 函数可以**引用在它之外声明的变量**。这些变量的集合叫做一个闭包。闭包被定义在 Lambda 表达式声明中的方括号 [] 内。这个机制允许这些变量被按值或按引用捕获。

```cpp
#include <bits/stdc++.h>  
using namespace std;  

int main(){  
    vector<int> alist;  
    int total = 0;  
    for (int i=0; i<5; ++i)   
        alist.push_back(i);  

    auto sumup = [&total](int x){total += x;};  

    for_each(begin(alist), end(alist), sumup);  
    cout << "total is: " << total << endl;  
}  
//输出结果：
total is: 10;
```

默认情况下，按值捕获的变量是不可以被修改的;非要修改的话，可以在参数列表后加关键字mutable；

如下：

```cpp
auto sumup=[total](int x)mutable{total+=x;};//total is :0;
```

sizeof(lambda表达式)等于多少？

> 编译器为lambda创建匿名类，那当然是sizeof(匿名类)的大小。sizeof(类)=sizeof(所有成员变量)

##### 位域

```
Bit mode: 2;    // mode 占 2 位
```

类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。

- 位域在内存中的布局是与机器有关的
- 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定
- 取地址运算符（&）不能作用于位域，任何指针都无法指向类的位域



##### explicit（显式）关键字

- explicit 修饰构造函数时，可以防止隐式转换和复制初始化

- explicit 修饰转换函数时，可以防止隐式转换，但 [按语境转换](https://zh.cppreference.com/w/cpp/language/implicit_conversion) 除外

  ```c++
  struct A
  {
  	A(int) { }
  	operator bool() const { return true; }
  };
  
  struct B
  {
  	explicit B(int) {}
  	explicit operator bool() const { return true; }
  };
  
  void doA(A a) {}
  
  void doB(B b) {}
  
  int main()
  {
  	A a1(1);		// OK：直接初始化
  	A a2 = 1;		// OK：复制初始化
  	A a3{ 1 };		// OK：直接列表初始化
  	A a4 = { 1 };		// OK：复制列表初始化
  	A a5 = (A)1;		// OK：允许 static_cast 的显式转换 
  	doA(1);			// OK：允许从 int 到 A 的隐式转换
  	if (a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
  	bool a6（a1）;		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
  	bool a7 = a1;		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
  	bool a8 = static_cast<bool>(a1);  // OK ：static_cast 进行直接初始化
  
  	B b1(1);		// OK：直接初始化
  	B b2 = 1;		// 错误：被 explicit 修饰构造函数的对象不可以复制初始化
  	B b3{ 1 };		// OK：直接列表初始化
  	B b4 = { 1 };		// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
  	B b5 = (B)1;		// OK：允许 static_cast 的显式转换
  	doB(1);			// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
  	if (b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
  	bool b6(b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
  	bool b7 = b1;		// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
  	bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化
  
  	return 0;
  }
  ```



##### using

**using 声明**

一条 `using 声明` 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：

```c++
using namespace_name::name;
```

**构造函数的 using 声明**

在 C++11 中，派生类能够重用其直接基类定义的构造函数。

```c++
class Derived : Base {
public:
    using Base::Base;
    /* ... */
};
```

如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：

```
Derived(parms) : Base(args) { }
```

**using 指示**

`using 指示` 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：

```
using namespace_name name;
```

**尽量少使用 `using 指示` 污染命名空间**

> 一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它**只导入了指定的名称**。如果该名称与局部名称发生冲突，编译器将**发出指示**。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则**局部名称将覆盖名称空间版本**，而编译器**并不会发出警告**。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。

**using 使用**

尽量少使用 `using 指示`

```c++
using namespace std;
```

应该多使用 `using 声明`

```c++
int x;
std::cin >> x ;
std::cout << x << std::endl;
```

或者

```c++
using std::cin;
using std::cout;
using std::endl;
int x;
cin >> x;
cout << x << endl;
```

##### :: 范围解析运算符

**分类**

1. 全局作用域符（`::name`）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
2. 类作用域符（`class::name`）：用于表示指定类型的作用域范围是具体某个类的
3. 命名空间作用域符（`namespace::name`）:用于表示指定类型的作用域范围是具体某个命名空间的

:: 使用

```c++
int count = 11;         // 全局（::）的 count

class A {
public:
	static int count;   // 类 A 的 count（A::count）
};
int A::count = 21;

void fun()
{
	int count = 31;     // 初始化局部的 count 为 31
	count = 32;         // 设置局部的 count 的值为 32
}

int main() {
	::count = 12;       // 测试 1：设置全局的 count 的值为 12

	A::count = 22;      // 测试 2：设置类 A 的 count 为 22

	fun();		        // 测试 3

	return 0;
}
```

##### enum 枚举类型

**限定作用域的枚举类型**

```c++
enum class open_modes { input, output, append };
```

**不限定作用域的枚举类型**

```c++
enum color { red, yellow, green };
enum { floatPrec = 6, doublePrec = 10 };
```



##### decltype

decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：

```c++
decltype ( expression )
```

decltype 使用

```c++
// 尾置返回允许我们在参数列表之后声明返回类型
template <typename It>
auto fcn(It beg, It end) -> decltype(*beg)
{
    // 处理序列
    return *beg;    // 返回序列中一个元素的引用
}
// 为了使用模板参数成员，必须用 typename
template <typename It>
auto fcn2(It beg, It end) -> typename remove_reference<decltype(*beg)>::type
{
    // 处理序列
    return *beg;    // 返回序列中一个元素的拷贝
}
```

##### 引用

**左值引用**

常规引用，一般表示对象的身份。

**右值引用**

右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。

右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：

- 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
- 能够更简洁明确地定义泛型函数。

**左值引用和右值引用的区别**

1. 左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被const修饰成常量引用了。
2. 可以取地址的，有名字的，非临时的就是左值；不能取地址的，没有名字的，临时的就是右值；
3. 右值引用的存在并不是为了取代左值引用，而是充分利用右值(特别是临时对象)的构造来减少对象构造和析构操作以达到提高效率的目的。
4. 带右值引用参数的拷贝构造和赋值重载函数，又叫移动构造函数和移动赋值函数，这里的移动指的是把临时量的资源移动给了当前对象，临时对象就不持有资源为nullptr了，实际上没有进行任何的数据移动，没发生任何的内存开辟和数据拷贝。

##### 继承

类可以**继承**（继承允许我们依据另一个类来定义一个类，后面章节会详细讲解），那么此时**成员访问属性会发生变化**：

（1）public: 公有继承时，对基类的公有成员和保护成员的访问属性不变，派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员。派生类的**对象**只能访问派生类的公有成员（包括继承的公有成员），访问不了保护成员和私有成员。

（2）protected: **保护继承中，基类的公有成员和保护成员被派生类继承后变成保护成员**，派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员。派生类的**对象**不能访问基类的公有成员，保护成员和私有成员。

（3）private: **私有继承时，基类的公有成员和保护成员都被派生类继承下来之后变成私有成员**，派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员。派生类的**对象**不能访问基类的公有成员，保护成员和私有成员。

**总结:** 不管是哪种继承方式，**派生类中新增成员可以访问基类的公有成员和保护成员，无法访问私有成员。**但是只有**公有继承**中，派生类的**对象**能访问**基类的公有成员**。使用友元（friend）可以访问保护成员和私有成员。

以下`Student1`有4个受保护的成员；**保护继承中，基类的公有成员和保护成员被派生类继承后变成保护成员**

```cpp
class Student{ 
public: 
    void display(); 
protected: 
    int num; 
    string name; 
    char sex; 
}; 
 
class Student1:protected Student{ 
public: 
    void display1(); 
private: 
    int age; 
    string addr; 
};
```

##### 拷贝构造函数调用的时机

> **拷贝构造函数**是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：
>
> - 通过使用另一个同类型的对象来初始化新创建的对象。
> - 复制对象把它作为参数传递给函数。
> - 复制对象，并从函数返回这个对象。
>
> 如果在类中没有定义拷贝构造函数，编译器会自行定义一个。**如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数**。原因是涉及到**深拷贝浅拷贝**的问题



##### 友元函数

**定义：**类的**友元函数**是定义在**类外部**，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是**友元函数并不是成员函数**。友元可以是一个函数，该函数称为友元函数，

**声明方式：**如果要声明函数为一个类的友元，需要在类的定义中在该函数原型前使用关键字friend;

**调用方式：**可以直接调用友元函数，不需要通过对象或者指针；

**缺陷：**友元函数有权访问类的所有私有（private）成员和保护（protected）成员。这破坏了类的**封装性**；所以通常不建议使用友元；



##### 成员初始化列表使用场景

- ==初始化列表比构造函数效率更高==：少了一次调用默认构造函数的过程。
- 有些场合必须要用初始化列表：
  1. const常量成员，因为==常量只能初始化不能赋值==，所以必须放在初始化列表里面
  2. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
  3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化



##### initializer_list 列表初始化

用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 `std::initializer_list` 参数.

initializer_list 使用

```c++
#include <iostream>
#include <vector>
#include <initializer_list>
 
template <class T>
struct S {
    std::vector<T> v;
    S(std::initializer_list<T> l) : v(l) {
         std::cout << "constructed with a " << l.size() << "-element list\n";
    }
    void append(std::initializer_list<T> l) {
        v.insert(v.end(), l.begin(), l.end());
    }
    std::pair<const T*, std::size_t> c_arr() const {
        return {&v[0], v.size()};  // 在 return 语句中复制列表初始化
                                   // 这不使用 std::initializer_list
    }
};
 
template <typename T>
void templated_fn(T) {}
 
int main()
{
    S<int> s = {1, 2, 3, 4, 5}; // 复制初始化
    s.append({6, 7, 8});      // 函数调用中的列表初始化
 
    std::cout << "The vector size is now " << s.c_arr().second << " ints:\n";
 
    for (auto n : s.v)
        std::cout << n << ' ';
    std::cout << '\n';
 
    std::cout << "Range-for over brace-init-list: \n";
 
    for (int x : {-1, -2, -3}) // auto 的规则令此带范围 for 工作
        std::cout << x << ' ';
    std::cout << '\n';
 
    auto al = {10, 11, 12};   // auto 的特殊规则
 
    std::cout << "The list bound to auto has size() = " << al.size() << '\n';
 
//    templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式，
                             // 它无类型，故 T 无法推导
    templated_fn<std::initializer_list<int>>({1, 2, 3}); // OK
    templated_fn<std::vector<int>>({1, 2, 3});           // 也 OK
}
```

##### 构造函数和初始化列表区别：

​		初始化和赋值对内置类型（int、float、char）的成员没有什么大的区别，像上面的任一个构造函数都可以。对非内置类型成员变量，**为了避免两次构造**，推荐使用==类构造函数初始化列表==。但有的时候必须用带有初始化列表的构造函数：

1. 成员类型是没有默认构造函数的类，若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。

```cpp
class Sprout1{
public:
    Sprout1(int a):i(a){}
private:
    int i;
};
class Sprout2{
public:
    Sprout1 test1;

    Sprout2(Sprout1 &t1){
        test1 = t1;
    }
};
```

以上代码无法通过编译，因为Sprout2的构造函数中`test1 = t1`这一行实际上分成两步执行：

先调用Sprout1的**默认构造函数**来初始化test1，然后才赋值t1。但由于Sprout1没有默认的构造函数，所以无法调用默认构造函数来初始化test1，故而编译错误。

正确的代码如下，使用初始化列表代替赋值操作。

```cpp
class Sprout2{ //使用初始化列表
public:
    Sprout1 test1;

    Sprout2(Sprout1 &t1):test1(t1){}
};
```

2.**const 成员**或**引用类型**的成员。因为 const 对象或引用类型只能初始化，不能对他们赋值。

对于普通数据成员而言，其值的设定可以放在 初始化阶段或者普通计算阶段完成。对于 const类型和&引用类型数据成员，其初始化必须在初始化阶段完成。若通过普通计算阶段来初始化该值，**编译器会报错：该变量未初始化**。

```cpp
class Sprout{
private:
    const int ci;
    Value m2;
    Value m1;
    Value m3;
public:
    Sprout():m1(1),m2(2),m3(3),ci(120){
        cout << "Sprout:test" << endl;
    }
};
```

3.构造函数和初始化列表的效率

(1)**内置数据类型，复合类型（指针，引用）**- 在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的

(2).**用户定义类型（类类型）- 结果上相同，但是**性能上存在很大的差别。因为类类型的数据成员对象在进入函数体前已经构造完成，也就是说在成员初始化列表处进行构造对象的工作，调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成（如果并未提供，则使用编译器提供的默认按成员赋值行为）

```cpp
class Sprout1{
public:
    Sprout1(){ // 无参构造函数
        cout << "Construct Sprout1" << endl;
    }
    Sprout1(const Sprout1& t1){ // 拷贝构造函数
        cout << "Copy constructor for Sprout1" << endl;
        this->a = t1.a;
    }
    Sprout1& operator = (const Sprout1& t1){ // 赋值运算符
        cout << "assignment for Sprout1" << endl;
        this->a = t1.a;
        return *this;
    }
private:
    int a;
};
class Sprout2{ //不使用初始化列表
public:
    Sprout1 test1;
    Sprout2(Sprout1 &t1){
        test1 = t1;
    }
};

class Sprout2{ //使用初始化列表
public:
    Sprout1 test1;
    Sprout2(Sprout1 &t1):test1(t1){}
};

//测试代码
Sprout1 t1;
Sprout2 t2(t1);
```

```cpp
//不使用初始化列表
Construct Sprout1
Construct Sprout1
assignment for Sprout1

//使用初始化列表   
Construct Sprout1
Copy constructor for Sprout1
```

可以看到初始化列表，直接调用拷贝构造函数初始化test1，省去了调用默认构造函数的过程。这样**性能自然更高效**。

##### **初始化列表的成员初始化顺序**

C++ 初始化类成员时，是按照==声明的顺序初始化==的，而不是按照出现在初始化列表中的顺序。

```cpp
class Sprout {
    Sprout(int x, int y);
    int m_x;
    int m_y;
};

Sprout::Sprout(int x, int y) : m_y(y), m_x(x){
};
```

你可能以为上面的代码将会首先做 `m_y=y`，然后做 `m_x=x`，最后它们有相同的值。但是编译器先初始化 m_x，然后是 m_y,，因为它们是按这样的顺序声明的。结果是 m_x 将有一个不可预测的值。

因此为了避免这种，一个总是使用声明的顺序初始化列表；

##### **对象是值传递还是引用传递**

1. **引用传递对象**

   通常，使用**对象**作为参数的函数时，应按**引用**而不是按值来传递对象，这样可以有效的提高效率。

2. **原因**

   因为按值传递的时候，将会涉及到调用**拷贝构造函数生成临时的拷贝**，然后又调用析构函数，这在大型的对象上要比**传递引用**花费的时间多的多。当我们不修改对象的时候，应当将参数声明为const引用。

3. ```
   void goodGay(Building &building){//引用传递
       函数体
   }
   
   void goodGay(Building building){//值传递
       函数体
   }
   ```

   ##### 拷贝构造函数的参数类型为什么必须是引用

   > 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成**无穷递归**地调用**拷贝构造函数**。因此拷贝构造函数的参数必须是一个引用。否则无法完成拷贝，而且栈也会满。
   >
   > ```cpp
   > #include <iostream.h>   
   >   
   > class CExample  
   > {  
   >     int m_nTest;  
   > public:  
   >       
   >     CExample(int x):m_nTest(x) //带参数构造函数   
   >     {   
   >        cout << "constructor with argument/n";  
   >     }  
   >       
   >     CExample(const CExample & ex) //拷贝构造函数   
   >     {  
   >         m_nTest = ex.m_nTest;  
   >         cout << "copy constructor/n";  
   >     }  
   >       
   >     CExample& operator = (const CExample &ex)//赋值函数(赋值运算符重载)   
   >     {     
   >         cout << "assignment operator/n";  
   >         m_nTest = ex.m_nTest;  
   >         return *this;  
   >     }  
   >       
   >     void myTestFunc(CExample ex)  
   >     {  
   >     }  
   > };  
   >   
   > int main()  
   > {  
   >     CExample aaa(2);  
   >     CExample bbb(3);  
   >     bbb = aaa;  
   >     CExample ccc = aaa;  
   >     bbb.myTestFunc(aaa);  
   >       
   >     return 0;     
   > }  
   > /*输出结果：
   > constructor with argument      // CExample aaa(2);
   > constructor with argument      // CExample bbb(3);
   > assignment operator                // bbb = aaa;
   > copy constructor                      // CExample ccc = aaa;
   > copy constructor                      //  bbb.myTestFunc(aaa);
   > */
   > ```
   >
   > bbb对象已经实例化了，不需要构造，此时只是将aaa赋值给bbb，只会调用赋值函数；
   >
   > 但是ccc还没有实例化，因此调用的是拷贝构造函数，构造出ccc，而不是赋值函数
   >
   > 看第四个输出： **copy constructor           // CExample ccc = aaa;**
   >
   > 构造ccc，实质上是ccc.CExample(aaa); 我们假如拷贝构造函数参数不是引用类型的话， 那么将使得 ccc.CExample(aaa)变成aaa传值给ccc.CExample(CExample ex)，即CExample ex = aaa，因为 ex 没有被初始化， 所以 CExample ex = aaa 继续调用拷贝构造函数，接下来的是构造ex，也就是 ex.CExample(aaa)，必然又会有aaa传给CExample(CExample ex), 即 CExample ex = aaa;那么又会触发拷贝构造函数，就这下永远的递归下去。
   >
   > 拷贝构造函数的参数使用引用类型不是为了减少一次内存拷贝， 而是避免拷贝构造函数无限制的递归下去。

   **赋值构造函数可以值传递吗？**

   > 可以，为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用，这样就可以实现连等的功能（a = b = c）

##### nullptr调用成员函数可以吗？为什么？

```cpp
#include<iostream>
using namespace std;

class Animal{
public:
    void sleep(){
        cout<<"Animal sleep"<<endl;
    }
    void breathe(){
        cout<<"Animal breathe haha"<<endl;
    }
};

class fish:public Animal{
public:
    void breathe(){
        cout<<"fish bubble"<<endl;
    }
};

int main(){
    Animal *pAn=nullptr;
    pAn->breathe();//输出animal breathe haha;
    fish *pFish=nullptr;
    pFish->breathe();//输出fish bubble;
    return 0;
}

```

> 可以，因为在==编译对象时就绑定了对象地址==，和指针空不空没关系；
>
> `pAn->breathe();`编译的时候，函数的地址就和指针pAn绑定了；调用`breath(*this)`, this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为`this=nullptr`，运行出错。

##### 多态的理解

> 利用虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。
>
> 换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有**多种形态**，或者说有多种表现方式，我们将这种现象称为**多态**

##### 静态多态（编译期/早绑定）

函数重载：函数**重载**主要是在类成员中，可以有一组具有相同函数名，不同参数列表（类型、个数）的函数，这组函数被称为**重载函数**。

```c++
class Student{  
public:  
    void display(char str);  
    void display(int i);  
    int  display(double j);  
};  
```

```cpp
void display(char str)  -->  _Z5displayc
void display(int i)     -->  _Z5displayi
int display(double j)   -->  _Z3displayd
```

反汇编之后发现三个dispaly函数经过编译之后对应着不同的函数签名；

```
void display(char str)  -->  _Z5displayc
void display(int i)     -->  _Z5displayi
int display(double j)   -->  _Z3displayd
```

签名命名的方式是：**返回值+函数名+函数参数列表**。

##### 动态多态（运行期间/晚绑定）

- 虚函数：用 virtual 修饰成员函数，使其成为虚函数

 构成多态的充分条件： ==函数的参数一定是父类的指针或引用；子类一定要重写父类的虚函数；==

  **多态的底层—虚表**；虚函数表(是一个数组）是通过一块**连续内存来存储虚函数的地址**，这张表解决了继承，虚函数（重写）的问题，在有虚函数的对象实例中都存在一张虚函数表，虚函数表就像一张地图，指明了实际应该调用的虚函数。

在父类person和子类student中，都有一个变量_vfptr存储在头部，这是一个数组指针（虚表指针），所指的数组，就是我们说的虚表。虚表中依次存储了各个虚函数的地址，且==存放的顺序和代码中定义的虚函数的顺序一致==。当进行多态调用时，编译器根据传入对象的类别，找到对应的vfptr（虚表指针），再查看你要调用的函数在类中定义的位置，来找到该虚函数在虚表中存储的位置，实现调用。

**如果有一个子类继承父类；则他们两个的vfptr值不同，编译器会根据类的不同而分别为2种类，各自构建一个虚表。即虚表是从属于类的！**

而同一类的s和s1，他们的vfptr值相同，且对应虚函数的地址也相同，所以得出结论：**虚表指针是从属于对象的。也就是说，如果一个类含有虚表，==则该类的所有对象都会含有一个虚表指针，并且该虚表指针指向同一个虚表==。**

再看p和s，s继承p，s中重写了虚函数Buyticket，而不重写虚函数vfunc，在监视中，我们发现：s类中的虚函数Buyticket地址与p中的不同，而虚函数vfunc地址与p中的相同，所以得出结论：**当子类继承父类的虚函数，不进行重写的话，虚函数地址不变，而如果重写（覆盖），那么就会改变对应虚函数的地址，分配一块新内存存储重写后的虚函数。**

**虚表在编译时就开始创建**，构造函数实际是初始化_vfptr指向的位置。也就是说虚表不可能放在堆，栈中的。虚表存放在代码段和数据段都可以，都有可能。**一般虚表放在静态区（数据段中）**。

**注意：**

- **普通函数（非类成员函数）不能是虚函数**

- **静态函数（static）不能是虚函数**
  
  > - static成员**不属于任何类对象或类实例**，所以即使给此函数加上virutal也是没有任何意义的。
  > - 静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数**没有this指针**。所以无法访问vptr. 进而不能访问虚函数表。
  
- **构造函数为什么不能是虚函数？**

  > 首先，虚函数的唯一存在的原因就是为了构成多态，但是派生类并不继承构造函数，构造函数是在创建对象时自己主动调用的，不可能通过子类的指针或者引用去调用继承。所以没必要（主要原因）。另一方面，构造函数为类对象初始化了内存空间，里面保存指向虚函数的指针vfptr，如果构造函数是虚函数，导致没有实例化类对象，也就没有内存空间，也就不可能有虚函数。

- **内联函数不能是表现多态性时的虚函数**，解释见：[虚函数（virtual）可以是内联函数（inline）吗？](https://github.com/huihut/interview#虚函数virtual可以是内联函数inline吗)

```c++
class Shape                     // 形状类
{
public:
    virtual double calcArea()
    {
        ...
    }
    virtual ~Shape();
};
class Circle : public Shape     // 圆形类
{
public:
    virtual double calcArea();
    ...
};
class Rect : public Shape       // 矩形类
{
public:
    virtual double calcArea();
    ...
};
int main()
{
    Shape * shape1 = new Circle(4.0);
    Shape * shape2 = new Rect(5.0, 6.0);
    shape1->calcArea();         // 调用圆形类里面的方法
    shape2->calcArea();         // 调用矩形类里面的方法
    delete shape1;
    shape1 = nullptr;
    delete shape2;
    shape2 = nullptr;
    return 0;
}
```

##### 重载和重写的区别

> 1. **重载**（overload)
>
>    函数名相同，参数列表不同（参数类型、参数顺序),不能用返回值区分。
>
>    特点：
>
>    （1）作用域相同；
>
>    （2）函数名相同；
>
>    （3）参数列表必须不同，但返回值无要求；
>
>    特殊情况：若某一重载版本的函数前面有virtual关键字修饰，则表示它是虚函数，但它也是**重载的一个版本**。
>
>    作用效果：编译器根据函数不同的参数列表，将函数与函数调用进行**早绑定**，重载与多态无关，与面向对象无关，它只是一种语言特性。
>
> 2. **重写**（override)
>
>    派生类重定义基类的虚函数，既会覆盖基类的虚函数(多态)。
>
>    特点：
>
>    （1）作用域不同；
>
>    （2）函数名、参数列表、返回值相同；
>
>    （3）基类函数是virtual；
>
>    特殊情况：若派生类重写函数是一个重载版本，那么基类的其他同名重载函数将在子类中隐藏。
>
>    作用效果：父类指针和引用指向子类的实例时，通过父类指针或引用可以调用子类的函数，这就是C++的多态。



##### 析构函数

**析构函数必须为虚函数吗？**

> C++默认析构函数不是虚函数，因为申明虚函数会创建虚函数表，占用一定内存，当不存在继承的关系时，析构函数不需要申明为虚函数。
>
> 若存在继承关系时，析构函数必须申明为虚函数，这样父类指针指向子类对象，释放基类指针时才会调用子类的析构函数释放资源，否则**内存泄漏**。

虚析构函数是为了解决==基类的指针指向派生类对象，并用基类的指针删除派生类对象。==

虚析构函数使用

```c++
class Shape
{
public:
    Shape();                    // 构造函数不能是虚函数
    virtual double calcArea();
    virtual ~Shape();           // 虚析构函数
};
class Circle : public Shape     // 圆形类
{
public:
    virtual double calcArea();
    ...
};
int main()
{
    Shape * shape1 = new Circle(4.0);
    shape1->calcArea();    
    delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。
    shape1 = NULL;
    return 0；
}
```



##### 纯虚函数

包含纯虚函数的类称为**抽象类**（Abstract Class）。之所以说它抽象，是因为它**无法实例化**，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。

抽象类通常是作为**基类**，让派生类去实现**纯虚函数**。派生类必须实现纯虚函数才能被实例化。

```c++
virtual int A() = 0;
```

##### 虚函数、纯虚函数

- 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，**它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override）**，这样的话，编译器就可以使用后期绑定来达到多态了。**纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。**
- 虚函数在子类里面可以不重写；但纯虚函数必须在子类中重新定义才可以实例化子类。
- 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
- **带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用**。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。
- 虚基类是虚继承中的基类，具体见下文虚继承。



##### 虚函数指针、虚函数表

- 虚函数指针：**在含有虚函数类的对象中，指向虚函数表，在运行时确定。**
- 虚函数表：在程序只读数据段（`.rodata section`，见：[目标文件存储结构](https://github.com/kongxiuzhi/interview#目标文件存储结构)），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。

> [C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现](https://blog.twofei.com/496/)



##### 虚继承

![image-20210419152417746](https://i.loli.net/2021/04/19/kSGMUwHef92cO4t.png)

虚继承用于**解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。**使得派生类中只保留一份间接基类的成员，在继承方式前面加上virtual关键字就是虚继承；

```cpp
//间接基类A
class A{
protected:
    int m_a;
};

//直接基类B
class B: virtual public A{  //虚继承
protected:
    int m_b;
};

//直接基类C
class C: virtual public A{  //虚继承
protected:
    int m_c;
};

//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //正确
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};

int main(){
    D d;
    return 0;
}
```

![img](https://i.loli.net/2021/04/19/Vg3HpXu8YL4dqMc.png)

**我们不提倡在程序中使用多继承**，只有在比较简单和不易出现二义性的情况或实在必要时才使用多继承，**能用单一继承解决的问题就不要使用多继承**。



底层实现原理与编译器相关，一般通过**虚基类指针**和**虚基类表**实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

实际上，**vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table）**，**虚表中记录了虚基类与本类的偏移地址**；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。



##### 虚继承、虚函数

- 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
- 不同之处：
  - 虚继承
    - **虚基类依旧存在继承类中，只占用存储空间**
    - **虚基类表存储的是虚基类相对直接继承类的偏移**
  - 虚函数
    - **虚函数不占用存储空间**
    - **虚函数表存储的是虚函数地址**

##### 虚继承类的内存占用大小

> 计算一个类对象的大小时的规律：
> 1、空类、单一继承的空类、多重继承的空类所占空间大小为：1（字节，下同，为了用来标识这个类，**使得一个类的两个对象在内存中有独一无二的地址**）；
> 2、一个类中，虚函数本身、成员函数（包括静态与非静态）和==静态数据成员==都是不占用类对象的存储空间的；
> 3、因此一个对象的大小≥所有非静态成员大小的总和；
> 4、当类中声明了**虚函数**（不管是1个还是多个），那么在实例化对象时，编译器会自动在对象里安插一个**指针vPtr指向虚函数表VTable**；
> 5、虚继承的情况：由于涉及到**虚函数表和虚基表**，会同时增加一个（多重虚继承下对应多个）vfPtr指针指向**虚函数表vfTable和一个vbPtr指针指向虚基表vbTable**，这两者所占的空间大小为：8（或8乘以多继承时父类的个数）；
> 6、在考虑以上内容所占空间的大小时，还要注意编译器下的“补齐”padding的影响，即编译器会插入多余的字节补齐；
> 7、类对象的大小=各非静态数据成员（包括父类的非静态数据成员但都不包括所有的成员函数）的总和+ vfptr指针(多继承下可能不止一个)+vbptr指针(多继承下可能不止一个)+编译器额外增加的字节。

##### 模板

模版元编程完全不同于普通的运行期程序，**因为模版元程序的执行完全是在编译期，**并且模版元程序操纵的数据**不能是运行时变量，只能是编译期常量，不可修改**。

函数模板：

```cpp
/*template<typename T>被称为模板头。

函数模板也可以提前声明，不过声明时需要带上模板头，并且模板头和函数定义（声明）是一个不可分割的整体，它们可以换行，但中间不能有分号*/
template<typename T> void Swap(T *a, T *b){
    T temp = *a;
    *a = *b;
    *b = temp;
}

//交换 int 变量的值
int n1 = 100, n2 = 200;
Swap(&n1, &n2);

//交换 float 变量的值
float f1 = 12.5, f2 = 56.93;
Swap(&f1, &f2);
```

**函数模板与模板函数：**

**函数模板**的重点是模板。表示的是一个**模板**，专门用来生产函数。

**模板函数**是函数模板的一个实例化。

模板与类的结合就是**类模板**

```cpp
template<class T> //声明一个模板，虚拟类型名为T  
class Operation{//操作整数的类  
public:  
    Operation （T a, T b) : x(a), y(b){}  
    T add() {  
        return x+y;  
    }  
    T subtract(){  
        return x-y;  
    }  
private:  
    T x, y;  
};

//申明一个类模板的对象；
Operation<int>obj(1,2);
```

**类模版** （class template）说明的是该类是一个模版，它代表的是整个类家族的参数化描述。

**模板类**是类模板具体的一个实例化。



**可变参模板**

```cpp
template<typename ...T>

#include <iostream>  
using namespace std;  
template <typename ... T>  
void func(T ... args){  
    cout << "num is " << sizeof ... (args) << endl;  
}  

int main(){  
    func();//没有参数  
    func(1);//一个int参数  
    func(1, 1.2, 'A');//一个int，一个double，一个char  
    return 0;  
}  

//运行结果如下：
num is 0
num is 1
num is 3
```

**其中T叫做模板参数包，args叫做函数参数包**。

省略号的作用如下：

（1）声明一个包含0到任意个模板参数的参数包

（2）在模板定义的右边，可以将参数包展开成一个个独立的参数

##### 模板类、成员模板

- 模板类中可以使用虚函数
- 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数



##### 抽象类、接口类、聚合类

- 抽象类：含有纯虚函数的类
- 接口类：仅含有纯虚函数的抽象类
- 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
  - 所有成员都是 public
  - 没有定义任何构造函数
  - 没有类内初始化
  - 没有基类，也没有 virtual 函数



##### extern关键字

**extern "C"**

- 被 extern 限定的函数或变量是 extern 类型的
- 被 `extern "C"` 修饰的变量和函数是按照 C 语言方式编译和链接的

`extern "C"` 的作用是让 C++ 编译器将 `extern "C"` 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

extern "C" 使用

```c++
#ifdef __cplusplus
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```

##### struct 和 typedef struct

**C 中**

```c++
// c
typedef struct Student {
    int age; 
} S;
```

等价于

```c++
// c
struct Student { 
    int age; 
};

typedef struct Student S;
```

此时 `S` 等价于 `struct Student`，但两个标识符名称空间不相同。

另外还可以定义与 `struct Student` 不冲突的 `void Student() {}`。

**C++ 中**

由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。

一、如果在类标识符空间定义了 `struct Student {...};`，使用 `Student me;` 时，编译器将搜索全局标识符表，`Student` 未找到，则在类标识符内搜索。

即表现为可以使用 `Student` 也可以使用 `struct Student`，如下：

```
// cpp
struct Student { 
    int age; 
};

void f( Student me );       // 正确，"struct" 关键字可省略
```

二、若定义了与 `Student` 同名函数之后，则 `Student` 只代表函数，不代表结构体，如下：

```c++
typedef struct Student { 
    int age; 
} S;

void Student() {}           // 正确，定义后 "Student" 只代表此函数

//void S() {}               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名

int main() {
    Student(); 
    struct Student me;      // 或者 "S me";
    return 0;
}
```

**C++ 中 struct 和 class**

总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。

**区别**

- 最本质的一个区别就是默认的访问控制

> 1.class默认成员都是private，而struct中默认成员都是public。
>
> 2.class的默认继承也是private，而struct中的默认继承都是public
>
> 3.class可以使用模板，而struct不行。
>
> 另外，在C语言中，struct 只能包含成员变量，不能包含成员函数。而在C++中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。

##### 结构体内存对齐

> 内存对齐的原则如下：
>
> ```rust
> 1、 分配内存的顺序是按照声明的顺序。
> 2、 每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。
> 3、 最后整个类的大小必须是里面变量类型最大值的整数倍。
> ```
>
> 为什么要对齐
>
> a.平台原因(移植原因)：某些硬件平台只能在某些地址处取某些特定类型的数据，不能访问任意地址。
>
> b.性能原因：访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问

##### union 联合

​       联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：

- 默认访问控制符为 public
- 可以含有构造函数、析构函数
- 不能含有引用类型的成员
- 不能继承自其他类，不能作为基类
- 不能含有虚函数
- 匿名 union 在定义所在作用域可直接访问 union 成员
- 匿名 union 不能包含 protected 成员或 private 成员
- 全局匿名联合必须是静态（static）的

**union 使用**

```c++
#include<iostream>

union UnionTest {
    UnionTest() : i(10) {};
    int i;
    double d;
};

static union {
    int i;
    double d;
};

int main() {
    UnionTest u;

    union {
        int i;
        double d;
    };

    std::cout << u.i << std::endl;  // 输出 UnionTest 联合的 10

    ::i = 20;
    std::cout << ::i << std::endl;  // 输出全局静态匿名联合的 20

    i = 30;
    std::cout << i << std::endl;    // 输出局部匿名联合的 30

    return 0;
}
```

##### this指针

每一个==成员函数中都包含一个特殊的指针，称为this指针，它是指向本类对象的指针，它的值是当前被调用的成员函数所在对象的起始地址==；**this是一个指针，它时时刻刻指向你这个实例本身**

this指针使用时的注意事项：

> （1）只能在成员函数中使用，在全局函数、静态成员函数中都不能使用this。
>
> （2）this指针是在成员函数的开始前构造，并在成员函数的结束后清除。
>
> （3）this指针会因编译器不同而有不同的存储位置，可能是栈、寄存器或全局变量。
>
> （4）this是类的指针。

```cpp
class Cylinder{//圆柱类  
public:  
    float volume(){return PI*radius*radius*hight;};//求体积  
    static float PI;  
private:  
    float radius;//半径  
    float hight;//高  
};  
float Cylinder::PI = 3.1415926;  
Cylinder obj;  
obj.volume(); 
```

当调用成员函数obj.volume();时，编译系统就把对象obj的**起始地址**赋给**this指针**，在成员函数引用数据成员时，就按照**this的指向**找到对象obj的**数据成员**。volume()计算`PI*radius*radius*hight`;的值，实际上是执行：

```
PI*(this->radius)*(this->radius)*(this->hight); 
```

`*this`则表示被调用成员函数所在的对象，如果出现`*this`，就是对象`obj`。`this`指针是**指向当前对象**的，但**静态成员变量和函数**不从属于某个对象，那当然没有this指针了，也不能访问非静态成员变量和函数。所以这里的`PI`并没有通过this指针访问。

同样的，友元函数没有 **this** 指针，因为友元不是类的成员。只有成员函数才有 **this** 指针

1. `this` 指针是一个隐含于每一个**非静态成员函数**中的特殊指针。它指向调用该成员函数的那个对象。

2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。

3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。

4. `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明不能对 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；

5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。

6. 在以下场景中，经常需要显式引用this指针：

   1. 为实现对象的链式引用；
   2. 为避免对同一对象进行赋值操作；
   3. 在实现一些数据结构时，如 `list`。

##### 虚函数（virtual）可以是内联函数（inline）吗？

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。

- 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此**虚函数表现为多态性时（运行期）不可以内联。**

- `inline virtual` 唯一可以内联的时候是：**编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。**

- ```c++
  #include <iostream>  
  using namespace std;
  class Base
  {
  public:
  	inline virtual void who()
  	{
  		cout << "I am Base\n";
  	}
  	virtual ~Base() {}
  };
  class Derived : public Base
  {
  public:
  	inline void who()  // 不写inline时隐式内联
  	{
  		cout << "I am Derived\n";
  	}
  };
  
  int main()
  {
  	// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
  	Base b;
  	b.who();
  
  	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
  	Base *ptr = new Derived();
  	ptr->who();
  
  	// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
  	delete ptr;
  	ptr = nullptr
  
  	system("pause");
  	return 0;
  } 
  ```

## STL容器相关

#### STL二级内存分配 allocator分配机制

![image-20220320163104510](https://s2.loli.net/2022/03/20/qnI3P41mEL2RKSO.png)

malloc 通过 brk() 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用；
malloc 通过 mmap() 方式申请的内存，free 释放内存的时候，会把内存归还给操作系统，内存得到真正的释放

> 第二级空间配置器 处理小的内存分配，维护一个**free_list  空闲待分配内存链表** ，链表连接的空闲内存区以8的倍数大小存储，还维护一个内存池；当有内存分配请求时，首先看是要调用第一级还是第二级空间配置器，当需要调用第二级空间配置器时，便在内存链表寻找最合适的空闲空间返回地址，如果内存表没有合适大小的区域，就向内存池请求分配最接近需求大小的空间若干个，返回给free_list, 并将第一个分配出去，如果内存池枯竭，就向系统空间索要新的空闲内存区间作为内存池使用，如果没有则使用第一级空间配置器，因为第一级配置器可以进行释放整理内存，继续在更大范围内寻找空闲内存，如果找不到，第一级内存配置器就抛出异常

#### 说说vector的实现原理

vector是数组的进一步封装，它是一个类。可以比数组**更加灵活的处理内存空间**。

vector采用的数据结构是线性的连续空间，它以两个迭代器**start**和**finish**分别指向配置得来的连续空间中目前已将被使用的空间。迭代器end_of_storage指向整个连续的尾部。

vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新的元素。vector在增加元素时，如果超过自身最大的容量Capacity，vector则将自身的容量**扩充为原来的两倍**。扩充空间需要经过的步骤：重新配置空间，元素移动，释放旧的内存空间。一旦vector空间重新配置，则指向原来vector的所有迭代器都失效了，因为vector的地址改变了。

#### vector中的push_back和emplace_back的区别

emplace的这些操作构造而不是拷贝元素，当调用push函数时，我们将元素类型的对象传递给他们，这些对象被拷贝到容器中，而调用emplace函数时，则是将参数传递给元素类型的构造函数，emplace成员使用这些参数在容器管理的内存空间中之间构造元素。

在引入右值引用，转移构造函数，转移复制运算符之前，通常使用push_back()向容器中加入一个右值元素(临时对象)时，首先会调用构造函数构造这个临时对象，然后需要调用拷贝构造函数将这个临时对象放入容器中。原来的临时变量释放。这样造成的问题就是临时变量申请资源的浪费。 
引入了右值引用，转移构造函数后，push_back()右值时就会调用构造函数和转移构造函数,如果可以在插入的时候直接构造，就只需要构造一次即可。这就是c++11 新加的emplace_back。


#### vector中erase的使用

```c++
vector<int>::iterator iter=vec.begin();  
for(; iter!=vec.end();){  
    if(*iter == 3)  
        iter = vec.erase(iter);  
    else  
        ++iter;  
}  
```

#### 迭代器的类型

> （1）**list，set、multiset，map 和 multimap 容器中定义的迭代器属于双向迭代器类型。**
>
> （2）**array，vector，deque，string 容器定义的迭代器就是随机访问迭代器类型。**
>
> （3）stack、queue不支持随机访问，**因此不存在迭代器。**不应该排序堆栈或队列 在中间添加项目
>
> （4）std ::sort 不能用于list，因为不是随机访问迭代器，要自己重写

#### vector的迭代器删除和map，set迭代器的删除有什么区别？

> vector的底层数据结构依然是采用的**数组**。数组在删除元素时，后面的元素都会往前移动，自然原有的迭代器就失效；
>
> map，set则不一样，map，set的数据结构采用的**红黑树**，删除当前元素时，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。
>
> 而对于list来说，它的数据结构是**链表**，使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此两种方式都可采用。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
    vector<int>v = { 1,2,3,4,5,6,7,8,9};
    for(auto iter = v.begin() ;iter != v.end();){
        if((*iter) % 3 == 0){
            iter = v.erase(iter);
            //v.erase(iter++); 错误，因为序列式容器的迭代器删除位置后的全部失效
        }
        else{
            iter++;
        }
    }
    for(auto p : v){
        cout << p <<endl;
    }
    list<int>l = { 1,2,3,6,3,7,9};
    for(auto iter= l.begin();iter != l.end();){
        if((*iter) == 3){
            //l.erase(iter++);
            iter = l.erase(iter);
        }else{
            iter++;
        }
    }
    for(auto p : l){
        cout << p <<endl;
    }
    map<string,int>mp={{"1",2},{"2",3},{"3",4}};
#if 0
    for(auto iter = mp.begin();iter != mp.end();){
        if((*iter).first == "1"){
            mp.erase(iter++);//对于关联式的容器，红黑树，只删除一个节点，下一个迭代器有效
        }else{
            iter++;
        }
    }
#endif
    for(auto iter = mp.begin();iter != mp.end();){
        if((*iter).first == "1"){
            iter = mp.erase(iter);
        }else{
            iter++;
        }
    }

    for(auto &[key,value] : mp){
        cout << "key :" <<key << "value :" <<value<<endl;
    }
    return 0;
}
```



#### 迭代器和指针有什么区别？

> 迭代器不是指针，是**类模板**，表现的像指针。它只是模拟了指针的一些功能，通过重载了指针的一些操作符，如`->`、`*`、`++`、`--`等。
>
> 迭代器封装了指针，是一个“可遍历STL容器内全部或部分元素”的对象，本质是封装了原生指针，是指针概念的一种提升，相当于**智能指针**。而迭代器的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。这就是迭代器产生的原因。

#### 迭代器前置++和后置++的区别

```cpp
CTest CTest::operator++(){  //前置++  
    *this += 1;  
    return *this;  
}  
CTest CTest::operator++(int){  //后置++  
    CTest tmp(*this);  //记录修改前的对象  
    ++(*this);  
    return tmp;  //返回修改前的对象  
}  
```

后置++要多生成一个**局部对象 tmp**，这个对象有可能包含很多的成员，因此执行速度比前置的慢。在次数很多的循环中，++i和i++可能就会造成运行时间上可观的差别

## 操作系统

#### cpu工作原理

CPU的运行原理就是：**控制单元**在时序脉冲的作用下，将**程序计数器**里所指向的指令地址送到地址总线上去，然后CPU将这个地址里的指令读到**指令寄存器**进行译码。对于执行指令过程中所需要用到的数据，会将数据地址也送到地址总线，然后CPU把数据读到CPU的**内部存储单元**(就是内部寄存器)暂存起来，最后命令**运算单元**对数据进行处理加工。这个过程不断重复，直到程序结束。

#### CPU层级的代码优化

> 三级缓存：所有核心公用三级缓存
>
> 提高CPU缓存命中率

```cpp
//按行---更好
for(int i = 0 ; i< n;i++){
    for(int j = 0 ; j < m;j++){
        arr[i][j] = 0;
    }
}
// 按列
for(int i = 0 ; i< n;i++){
    for(int j = 0 ; j < m;j++){
        arr[i][j] = 0;
    }
}
```

分支预测器：if else 执行概率大的部分

```cpp
#define pass(x) __builtin_expect(!!(x),1)
```



#### 并发和并行

同一时刻单个CPU只能处理一个任务，但不停地在多个任务来回快速切换，这就是**并发**

为了能同时处理多个任务，出现了**多核CPU**，即一个CPU芯片里面包含了多个处理器或内核，相当于一个CPU芯片包含了多个独立的小CPU，每个小CPU都能单独处理任务，所以一个多核CPU可以同时处理多个任务，这就是**并行**。

区别：**并发**的"同时"是经过不同线程快速切换，使得看上去多个任务同时都在运行的现象。**并行**的"同时"是同一时刻可以多个任务在运行(处于running)；

#### 存储器（物理内存层次）

![img](https://i.loli.net/2021/04/19/puMOD6clRQm7d5w.png)

顶层的**寄存器**速度快，但容量小，且成本高，寄存器存取速度快，用于程序中存储变量。

第二层是**高速缓存**，多由硬件控制。操作系统一直在使用缓存，例如多数操作系统在**缓存中保留频繁使用的文件**（的一部分），以避免从磁盘中重复地调取这些文件。这样主要就是为了提升访问的速度，从而带来性能上的提升。

下一层就是我们的**主存**。主存通常称为随机访问存储器（Random Access Memory，**RAM**），就是我们常说的**内存**。所有不能在高速缓存中得到满足的访问请求都会转往主存。

下一个层次是**磁盘**（硬盘）。磁盘成本低、容量大，但访问速度慢，低速的原因是因为磁盘是一种机械装置。

​		操作系统会对物理内存进行管理，有一个部分称为**内存管理器(memory manager)**，它的主要工作是有效的管理内存，记录哪些内存是正在使用的，在进程需要时分配内存以及在进程完成时回收内存。



![img](https://i.loli.net/2021/04/19/co7Vemp2kSPlwGI.png)

扇区是磁盘中最小的物理存储单位。通常情况下每个扇区的大小是512字节。扇面多个同心圆扇区组成。

**正因为磁盘是机械结构，读取数据时，磁头需要在盘面移动，读取的时间就延长了。**

**注意，固态硬盘不是磁盘，因为固态硬盘不是机械结构，数据是存储在存储器（闪存）中**

#### 常见存储器及作用

| 存储器类型 |                             简介                             |                             作用                             |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|    ROM     |                只读存储器（Read-Only Memory）                | 是一种只能读出事先所存数据的固态半导体存储器。其特性是一旦储存资料就无法再将之改变或删除。 |
|    RAM     |   随机存取存储器（random access memory）又称作“随机存储器”   | 是与CPU直接交换数据的内部存储器，也叫主存(内存)。它可以随时读写，而且速度很快。 |
|    SRAM    |      静态随机存取存储器（Static Random-Access Memory）       | 随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。然而，当电力供应停止时，SRAM储存的数据还是会消失。 |
|    DRAM    |                  动态随机存取存储器（DRAM）                  | DRAM里面所储存的数据就需要周期性地更新。要刷新充电一次，否则内部的数据即会消失。 |
|   EPROM    |         (Erasable Programmable ROM)，可擦除可编程ROM         | 芯片通过紫外线可重复擦除和写入,解决了PROM芯片只能写入一次的弊端。EPROM芯片在写入资料后,还要以不透光的贴纸或胶布把窗口封住,以免受到周围的紫外线照射而使资料受损。使用并不方便。 |
|   PSRAM    | 全称Pseudo static random access memory。指的是伪静态随机存储器。 | 内部的内存颗粒跟SDRAM的颗粒相似，但外部的接口跟SDRAM不同，不需要SDRAM那样复杂的控制器和刷新机制，PSRAM的接口跟SRAM的接口是一样的。PSRAM 内部自带刷新机制。 |
|   EEPROM   | (electrically erasable, programmable, read-only )是一种电可擦除可编程只读存储器 | 其内容在掉电的时候也不会丢失。在平常情况下，EEPROM与EPROM一样是只读的，需要写入时，在指定的引脚加 上一个高电压即可写入或擦除，而且其擦除的速度极快 |
|   Flash    |                              -                               | 它的主要特点是在不加电的情况下能长期保持存储的信息。就其本质而言，Flash Memory属于EEPROM(电擦除可编程只读存储器)类型。它既有ROM的特点，又有很高的存取速度，而且易于擦除和重写，功耗很小。 |
| NOR Flash  |                              -                               | NOR Flash的特点是芯片内执行(XIP, eXecute In Place)，这样应用程序可以直接在flash闪存内运行，不必再把代码读到系统RAM中。NOR Flash的传输效率很高，在1～4MB的小容量时具有很高的成本效益，但是很低的写入和擦除速度大大影响了它的性能。 |
| NAND Flash |                              -                               | NAND Flash结构能提供极高的单元密度，可以达到高存储密度，并且写入和擦除的速度也很快。应用NAND Flash的困难在于flash的管理需要特殊的系统接口。 |

#### I/O设备输入输出的三种方式

循环：用户程序发出一个系统调用，设备驱动程序启动I/O并在一个**循环中不断检查**该设备，看该设备是否完成了工作。当I/O结束后，设备驱动程序把数据送到指定的地方（若有需要），并返回。然后操作系统将控制返回给调用者。

中断：设备驱动程序启动设备并且让该设备在操作完成时发出一个**中断**.不需要一直轮询设备，在设备中断之前，操作系统可以处理其他事情，当中断来时再处理中断。

DMA:为I/O使用一种特殊的直接存储器访问（Direct Memory Access，**DMA**）芯片，它可以直接控制外围设备的数据流，而无需持续的CPU干预。这样效率就很高了，但对应成本就相对高些，因为DMA是由专门的硬件（ DMA）控制。

DMA的使用场景：DMA传送**主要用于需要高速大批量数据传送的系统中，以提高数据的吞吐量**。如**磁盘存取、图像处理、高速数据采集系统、同步通信中的收/发信号等**方面应用甚广。通常只有数据流量较大(kBps或者更高)的外设才需要支持DMA能力，这些应用方面典型的例子包括视频、音频和网络接口。

#### 软中断和硬中断

> Linux 将中断处理过程分成了两个阶段，也就是**上半部和下半部**：
>
> - **上半部用来快速处理中断**，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。（硬中断）
> - **下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行**。（软中断）
>
> 比如：网卡接收到数据包后，会通过**硬件中断**的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它。
>
> - 对上半部来说，既然是快速处理，其实就是要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了），最后再发送一个**软中断**信号，通知下半部做进一步的处理。
> - 而下半部被**软中断信号**唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。
>
> 所以，这两个阶段你也可以这样理解：
>
> - 上半部直接处理硬件请求，也就是我们常说的**硬中断**，特点是快速执行；
> - 而下半部则是由内核触发，也就是我们常说的**软中断**，特点是延迟执行

#### 程序和进程

程序是指令、数据及其组织形式的描述，而**进程**则是程序的运行实例，包括程序计数器、寄存器和变量的当前值。

Linux的进程结构，一般分为**三部分**：**代码段、数据段和堆栈段**。

**代码段**用于存放程序代码，如果有多个进程运行相同的一个程序，那么它们可以使用同一个代码段。

而**数据段**则存放程序的全局变量、常量和静态变量。

**堆栈段**中的栈用于函数调用，存放着函数的参数、局部变量。

#### **程序怎么转换为进程?**

> 程序的生成分为**四个阶段**：**预编译、编译、汇编和链接**，最后生成可执行文件。当程序执行时，**操作系统将可执行文件复制到内存中**，然后经过以下几个步骤转换为**进程**：
>
> 1. 内核将程序读入内存，为程序分配内存空间。
> 2. 内核为该进程分配**进程标识符**（**PID**，记住这个名称）和其他所需资源
> 3. 内核为进程保存PID及相应的状态信息，并且将进程放入运行队列中等待执行。
> 4. 由操作系统调度执行。

一个进程对应**唯一标识符PID**。标识符类型为pid_t，是一个无符号整型。同一个可执行程序可以被加载为多个不同的进程。因此进程与PID是一对一关系，而进程与程序文件之间是多对一关系

#### 进程和线程以及它们的区别？

> 进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中==分配和管理资源=的基本单位，每一个进程都有一个自己的地址空间，至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态
>
> 线程是进程的一个实体，是CPU==调度和分派==的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。
>
> （1）一个线程从属于一个进程；一个进程可以包含多个线程。
>
> （2）一个线程挂掉，对应的进程挂掉；一个进程挂掉，不会影响其他进程。
>
> （3）进程是操作系统资源分配的最小单位；线程CPU调度的最小单位。
>
> （4）进程系统开销显著大于线程开销；线程需要的系统资源更少。
>
> （5）进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。
>
> （6）进程切换时需要刷新TLB（Translation Lookaside Buffer，转译后备缓冲区，虚拟地址的缓存，用于改进虚拟地址到物理地址的转译速度）并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈。
>
> （7）通信方式不一样。
>
> （8）进程适应于多核、多机分布；线程适用于多核

#### 进程和线程相比，为什么慢？

> 1. 进程系统开销显著大于线程开销；线程需要的系统资源更少。
> 2. 进程切换开销比线程大。多进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈；多线程切换时只需要切换硬件上下文和内核栈。
> 3. 进程通信比线程通信开销大。进程通信需要借助管道、队列、共享内存，需要额外申请空间，通信繁琐；而线程共享进程的内存，如代码段、数据段、扩展段，通信快捷简单，同步开销更小。

- 进程、设备、文件、内存等由操作系统内核程序管理的对象，称为内核对象。内核对象需要占据内核地址空间中的内存块，由内核创建并维护，不同进程可以访问同一个内核对象。

  

#### 线程和协程之间的区别

线程从属于进程，而**协程**则是从属于线程。协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。

1. 协程执行效率极高。协程拥有自己的寄存器上下文和栈。协程调度切换时，恢复先前保存的寄存器上下文和栈，==直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快==。协程的切换只需要在用户态进行，不需要在系统用户态和内核态之间切换。因此，协程切换开销比线程更小。
2. 协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，正因为协程切换不需要加锁，只需要执行判断状态，因此效率比线程高。
3. 一个线程可以有多个协程，一个进程也可以单独拥有多个线程。 

#### 协程是轻量级线程，轻量级表现在哪里？

1. **协程调用跟切换比线程效率高**：协程执行效率极高。协程不需要多线程的锁机制，可以不加锁的访问全局变量，所以上下文的切换非常快。
2. **协程占用内存少**：执行协程只需要极少的栈内存（大概是4～5KB），而默认情况下，线程栈的大小为1MB。
3. **切换开销更少**：协程直接操作栈基本没有内核切换的开销，所以切换开销比线程少。

#### 进程间通信方式

1. **管道**:所谓管道，就是内核中一串缓存，内核缓冲区（4k)实现;**半双工管道**

   - 匿名管道：pipe，==只适用于有血缘关系的父子进程之间的通信==，通过fork子进程创建的子进程会复制父进程的文件描述符，两个进程都有两个fd[0]和fd[1]，为了能够正常通信，父进程关闭读取的fd[0]，只保留写入的fd[1]，子进程关闭fd[1]，只保留读取的fd[0]。
   - 命名管道：FIFO，本质也是文件，但是传递方向是双向的。适用于没有血缘关系的进程之间的通信，命令管道创建的实际上是一个类型为管道的文件，在系统中可见，在文件系统中拥有一个名称，所以可以适用于没有血缘关系进程之间的通信；

   管道这种通信方式效率比较低，进程写入的数据都是缓存在内核中，另一个进程读取数据时，从内核中获取，通信数据遵循先进先出的原则，==不适合进程间频繁交换地交换数据==。

2. **消息队列**:本质是保存在内核中的消息链； 消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的储存块，不像是管道无格式字节流数据，

   - 消息队列通信不及时，传输数据大小有限制
   - 消息队列不适合传输比较大的数据，因为内核中每个消息体都有一个最大长度的限制，在Linux内核中，会有两个宏定义 MSGMAX和MSGMNB,他们以字节为单位，分别定义一条消息的最大长度和队列的最大长度。
   - **消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销**，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。

3. **共享内存**

   - 消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那**共享内存**的方式，就很好的解决了这一问题。
   - 现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。
   - **共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中**。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。

4. **信号量**

   - 用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。

   - 为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，**信号量**就实现了这一保护机制

     **信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据**

     - **原理**：由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv)，具体的行为如下：

       （1）P(sv)操作：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行（信号量的值为正，进程获得该资源的使用权，进程将信号量减1，表示它使用了一个资源单位）。

       （2）V(sv)操作：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1（若此时信号量的值为0，则进程进入挂起状态，直到信号量的值大于0，若进程被唤醒则返回至第一步）。

     P操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程。

   5.**信号**

   **信号**（signal）是linux进程通信中唯一的异步通讯方式。**信号从软件层次上看是对中断机制的一种模拟。一个进程收到信号时的处理方式与CPU收到中断请求时的处理方式一样。收到信号的进程会跳入信号处理函数，执行完后再跳回原来的位置继续执行**

   > Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。
   >
   > **匿名管道**顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「`|`」竖线就是匿名管道，通信的数据是**无格式的流并且大小受限**，通信的方式是**单向**的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来**匿名管道是只能用于存在父子关系的进程间通信**，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。
   >
   > **命名管道**突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是**缓存在内核**中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循**先进先出**原则，不支持 lseek 之类的文件定位操作。
   >
   > **消息队列**克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟**每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。**
   >
   > **共享内存**可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，**它直接分配一个共享空间，每个进程都可以直接访问**，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有**最快**的进程间通信方式之名。但是便捷高效的共享内存通信，**带来新的问题，多进程竞争同个共享资源会造成数据的错乱。**
   >
   > 那么，就需要**信号量**来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。**信号量不仅可以实现访问的互斥性，还可以实现进程间的同步**，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 **P 操作和 V 操作**。
   >
   > 与信号量名字很相似的叫**信号**，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中**唯一的异步通信机制**，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，**进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号**。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SEGSTOP`，这是为了方便我们能在任何时候结束或停止某个进程。
   >
   > 前面说到的通信机制，都是工作于同一台主机，如果**要与不同主机的进程间通信，那么就需要 Socket 通信了**。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。

#### 线程间通信方式

线程间通性方式主要是为了解决线程间同步的问题。有四种方式；

> 1.互斥锁；2.信号量；3.条件变量；4.读写锁；
>
> 同步是指在一定时间内只允许某一线程访问某个资源；

1.**互斥锁**

互斥锁一般被设置成**全局变量**。打开的互斥锁可以由某个线程获得。一旦获得，这个互斥锁会锁上，此后只有该线程有权打开，其他想要获得互斥锁的线程，会等待直到互斥锁再次打开的时候。

2.**信号量**

信号量本质上是一个**非负的整数计数器**，它被用来控制对公共资源的访问。

编程时可根据操作信号量值的结果判断是否对公共资源具有访问的权限，当信号量值大于等于0时，则可以访问，否则将阻塞。**PV原语是对信号量的操作，一次P操作使信号量减1，一次V操作使信号量加1**；

3.**条件变量**

与互斥锁不同，**条件变量是用来等待而不是用来上锁的**。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通**常条件变量和互斥锁同时使用**。

4.**读写锁**

**读写锁**。读写锁与互斥量类似。但**互斥量要么是锁住状态，要么就是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高，读写锁适合于对数据的读次数比写次数多得多的情况**

读写锁有3种状态：读模式下加锁状态、写模式加锁状态、不加锁状态。**写锁优先级高于读锁**

==一次只有一个线程可以对其加锁==，不论是加读锁还是加写锁，一个线程正在读，另一个线程尝试加写锁，写锁优先级高于读锁，那这个正在读的线程会让出资源吗? 答案是不会。因为一次只有一个线程可以对资源加锁，必须读完了才会让出资源；

优先级的意思是，当有两个线程处于阻塞状态时，一个尝试读，一个尝试写，写锁优先级高于读锁，**当锁可以获取时，那么尝试写的线程先加锁**。

#### 互斥量和信号量的区别

1. 互斥量用于线程的互斥，信号量用于线程的同步。
2. 互斥量值只能为0/1，信号量值可以为非负整数。
3. 互斥锁保证资源同一时间只有一个线程访问；信号量可以多个线程访问同一资源

#### 有了进程，为什么还要有线程？

进程上下文:当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文

1. **原因**

   进程在早期的多任务操作系统中是基本的**执行单元**。每次进程切换，都要先保存进程资源然后再恢复，这称为上下文切换。**但是进程频繁切换将引起额外开销，从而严重影响系统的性能。**为了减少进程切换的开销，人们把两个任务放到一个进程中，每个任务用一个更小**粒度**的执行单元来实现并发执行，这就是**线程**。

2. **线程与进程对比**

   （1）**进程间的信息难以共享。**由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。

   但**多个线程共享**进程的内存，如代码段、数据段、扩展段，线程间进行信息交换十分方便。

   （2）调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。

   **但创建线程比创建进程通常要快 10 倍甚至更多。**线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表。

#### 单核机器上写多线程程序，是否要考虑加锁，为什么？

在单核机器上写多线程程序，仍然需要线程锁。

**原因**：因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，**不使用线程锁的前提下，可能会导致共享数据修改引起冲突。**

#### 简述互斥锁的机制，互斥锁与读写的区别？

1. **互斥锁机制**：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。

2. **互斥锁和读写锁**：

   （1） 读写锁区分读者和写者，而互斥锁不区分

   （2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象

#### 用户态与内核态

通常，在PSW（程序状态字）中有一个二进制位控制这两种模式。当在内核态运行时，CPU可以执行指令集中的每一条指令，并且使用硬件的每一种功能。

相反的，用户程序在用户态下运行，仅允许执行整个指令集的一个子集和访问所有功能的一个子集。相对应的，内核态与用户态也是操作系统的两种运行级别。内核态拥有最高权限，可以访问所有系统指令；用户态则只能访问一部分指令。

区分用户态和内核态的只要原因是出于安全的考虑；

怎么切换这两种状态呢

三种方式：1.系统调用；2.异常；3.设备中断；

异常：当CPU在执行运行在用户态的程序时，发生了某些事件不可知的异常，就会切换当前运行进程到处理此异常的内核相关的程序中，也就到了**内核态**，比如**缺页异常（硬中断）**

```
两个操作系统的概念，用户态，核心态
（1）当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。
（2）当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）
```

#### 什么是系统调用

> Linux内核中设置了一组用于实现各种系统功能的子程序，称为**系统调用**。用户可以通过系统调用命令在自己的应用程序中调用它们。从某种角度来看，系统调用和普通的函数调用非常相似。区别仅仅在于，系统调用由操作系统核心提供，运行于核心态；而普通的函数调用由函数库或用户自己提供，运行于用户态。
>
> **系统调用**的机制其核心还是使用了操作系统为用户特别开放的一个**中断**来实现，该中断是程序人员自己开发出的一种正常的异常，这个异常具体就是调用int $0x80$的汇编指令，这条汇编指令将产生向量为0x80的编程异常
>
> 产生中断（软中断）后，调用中断处理程序，调用System_call函数，就完成操作系统内核态的调用了

#### 进程的五状态(七状态模型)

**五状态模型**：

![image-20210315134553954](..\Study_Notes\图片\五状态模型)

```cpp
/*运行-->阻塞：I/O请求

阻塞-->就绪：I/O完成；


新建--->就绪：新建时仅仅创建了PCB信息，新建到就绪需要经过加载，即为程旭在内存中开辟空间
运行--->就绪：分时操作系统会设置一个时间片, 即每个进程可获得一段处理器执行时间. 多个进程按序获得处理器调用, 并执行时间片的时间, 从而营造出多个程序是同时运行的假象. 进程执行满相应时间片的时间后, 会从”运行”状态置为”就绪”状态.
```

​		我们知道只有在内存中的程序才会被处理器调用执行, 故所有等待被执行的程序都要首先被放入内存, 但内存是有限的, 有可能会出现不能调入所有待执行程序的情况, 而处理器速度非常快, 所以会出现内存中所有进程都被处理器执行了一遍, 都在等待I/O事件(即都是”阻塞”状态), 此时处理器空闲了, 却不能处理未进入内存的待执行程序.

​		因此操作系统引入了**挂起(交换)**的概念, 即**内存已满时, 操作系统会将内存中等待I/O的进程(即”阻塞”状态)移动到硬盘中, 并从硬盘中调入新的"就绪"进程**. 换出的进程被放置在挂起队列中, 由此引申出了七状态模型.

**七状态模型：**

![image-20210315135352577](..\Study_Notes\图片\七状态)

#### 进程的创建方式

进程的**创建方式**有两种：**一种由操作系统创建**；**一种由父进程创建**

1. 我们先讲由操作系统创建的进程。在系统启动时，操作系统会创建一些进程，它们承担着管理和分配资源的任务，这些进程维持这系统的稳定运行，被称为**系统进程**。
2. 另一种方式就是由**父进程创建**。系统允许一个进程创建新进程（即子进程），子进程又可以创建新的子进程，形成树结构。子进程创建成功后，子进程将存在于系统之中，并且独立于父进程。子进程可以接受系统调度，可以分配资源。那么创建一个子进程，常用**fork()函数**，其原型如下：

```cpp
#include <unistd.h> 
pid_t fork(void); 
 
/*
fork()函数不需要参数，返回值是一个进程标识符PID。返回值有以下三种情况：
（1）    对于父进程，fork()函数返回新创建的子进程的PID。
（2）    对于子进程，fork()函数调用成功会返回0。
（3）    如果创建出错，fork()函数返回-1。
```

fork()函数创建一个新进程后，会为这个新进程分配进程空间，将父进程的进程空间中的内容**复制**到子进程的进程空间中，包括父进程的数据段和堆栈段，并且和父进程**共享代码段**。这时候，子进程和父进程一模一样，都接受系统的调度。因为两个进程都停留在fork()函数中，最后fork()函数会返回两次，一次在父进程中返回，一次在子进程中返回，两次返回的值不一样。

具体实现:

```cpp
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
int main(){ 
    pid_t pid = fork(); 
    if (pid < 0){ 
        printf("fork error!"); 
        exit(-1); //退出进程 
    } 
    else if (pid == 0) 
        //子进程 getpid()用于获得当前进程的pid，而getppid()则是获取父进程的pid。
        printf("Child--PID : %u, Parent--PID : %u\n",getpid(),getppid()); 
    else{ 
        //父进程 
        printf("Parent--PID : %u, Child--PID : %u\n",getpid(),pid); 
        sleep(2); //休眠2s，让子进程先运行 
    } 
    return 0; 
}
//运行结果如下:
Child--PID : 4, Parent--PID : 3
Parent--PID : 3, Child--PID : 4
```

再次强调，子进程**完全复制**了父进程的地址空间的内容，包括数据段和堆栈段的内容。但是子进程却和父进程**共享代码段**，这个好理解，因为代码段只读，不会被修改，那么为节约进程空间，共享就行了。

Linux的后续发展中，当创建新进程时，连数据段和堆栈段都不再立马复制了，而是等到需要修改数据段或堆栈段的数据时再复制，这就是**写时复制**,既有父子进程的关系:**读时共享,写时复制;**vfork()函数就体现了写时复制的理念；

#### **守护进程**

**守护进程**是运行在后台的一种生存期长的特殊进程。它独立于控制终端，处理一些系统级别任务。

**创建过程**如下：

1. **创建子进程，终止父进程**。方法是调用fork()产生一个子进程，然后使父进程退出。

2. **调用setsid()创建一个新会话**。控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响，方法是调用setsid() 使进程成为一个会话组长。setsid() 调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。

   **进程组**：是一个或多个进程的集合。

   **会话周期**：会话期是一个或多个进程组的集合。

   **禁止进程重新打开控制终端**。经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。

3. **将当前目录更改为根目录**。使用fork() 创建的子进程也继承了父进程的当前工作目录。由于在进程运行过程中，当前目录所在的文件系统不能卸载，因此，把当前工作目录换成其他的路径，如根目录。

4. **重设文件权限掩码**。文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限。 由于使用 fork() 函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。 因此，把文件权限掩码设置为0 ，可以大大增强该守护进程的灵活性。 设置文件权限掩码的函数是umask ，通常的使用方法为 umask(0)。

5. **关闭不再需要的文件描述符**。子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。

实例:

```cpp
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <fcntl.h> 
#include <unistd.h> 
#include <sys/wait.h> 
#include <sys/types.h> 
#include <sys/stat.h> 
 
#define MAXFILE 65535 
 
int main(){ 
    //第一步:创建进程  
    int pid = fork(); 
 
    if (pid > 0) 
        exit(0);//结束父进程  
    else if (pid < 0){ 
        printf("fork error!\n"); 
        exit(1);//fork失败，退出  
    } 
    //第二步:子进程成为新的会话组长和进程组长,并与控制终端分离  
    setsid(); 
    //第三步:改变工作目录到 
    chdir("/"); 
    //第四步:重设文件创建掩模  
    umask(0); 
    //第五步:关闭打开的文件描述符 
    for (int i=0; i<MAXFILE; ++i)  
        close(i); 
    while (1){ 
        int fd; 
        if ((fd=open ("/tmp/douya.c", O_CREAT|O_WRONLY|O_APPEND, 0600)) < 0){
            perror("open"); 
            exit (1) ; 
        } 
        write(fd, "processing...\n", strlen("processing...\n")+1); 
        close(fd); 
        sleep(2); 
    } 
    return 0; 
}
```

编译后运行程序:`./douya_protected`

用指令看后台程序

```
ps -ef|grep protected
```

![img](https://i.loli.net/2021/04/19/b8dwMAWXIxJRy12.png)

#### 僵尸进程和孤儿进程

在Linux中，正常情况下，子进程是通过父进程创建的，子进程又创建新的进程，子进程退出后，**将由父进程调用wait()或者waitpid()系统调用取得子进程的终止状态**。然后就要回收子进程的资源.

然而子进程的结束和父进程的运行是一个异步过程，即父进程无法预测子进程什么时候结束。于是就会产生**孤儿进程**和**僵尸进程**。

1. **孤儿进程**，是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并且由init进程对它们完成状态收集工作。
2. **僵尸进程**，是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。

所以两者的**区别**是：孤儿进程是父进程已退出，子进程未退出；而僵尸进程是父进程未退出，子进程已退出。

```cpp
//僵尸进程的实例
#include <stdio.h> 
#include <unistd.h> 
#include <stdlib.h> 
 
int main() { 
    pid_t pc = fork(); //创建一个子进程 
    if (pc > 0){//父进程 
        printf("in parent process, wait some minutes...\n"); 
        sleep(10); 
        printf("after waiting, parent process exits!\n"); 
    } 
    else if (pc == 0){ 
        //子进程退出，父进程没有调用wait()或waitpid()系统调用 
        //子进程将成为一个僵尸进程 
        printf ("in child process, let it exist!\n"); 
        exit(0); 
    } 
    return 0; 
}
```

我们通过fork创建子进程，先让父进程等待10s钟，同时让子进程退出，而父进程没有调用wait()或waitpid()系统调用，使得子进程变为僵尸进程。

```cpp
//通过指令查看进程状态
ps - aux|grep -w 'Z'
```

![img](https://i.loli.net/2021/04/19/K7q5awsjApIrOdi.png)

可以清楚地看到，出现了一个僵尸进程。当我们的父进程10s等待完毕后，再次查看

![img](https://i.loli.net/2021/04/19/49AFBtNyoqeDm5w.png)

僵尸进程没有了。因为父进程退出后，这个僵尸进程已成为孤儿进程，由init进程管理，而init进程会周期性地调用**wait系统调用**来清除僵尸进程。

**如何解决僵尸进程问题？**

> (1)一般，为了防止产生僵尸进程，在fork子进程之后我们都要及时使用**wait系统调用**；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait（或waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的。
>
> (2)使用kill命令。
>
> 打开终端并输入下面命令
>
> ```
> ps aux|grep -Z
> kill -s SIGCHILD pid(父进程pid);
> //这样子进程退出之后，父进程就会收到信号
> ```
>
> 或者强制杀死父进程
>
> ```
> kill -9 pid(父进程pid);
> ```
>
> 这样父进程退出后，这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并且由init进程对它们完成状态收集工作。

#### wait()和waitpid()系统调用

我们前面说了，可以使用**wait()或waitpid()系统调用**，进程一旦调用了wait函数，就立即**阻塞**自己本身，然后由wait函数自动分析当前进程的某个子进程是否已经退出，当找到一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞，直到有一个出现为止。函数原型如下：

```cpp
#include<sys/types.h> 
#include<sys/wait.h> 
 
pid_t wait(int* status);
```

子进程的结束状态值会由参数**status**返回，而子进程的进程识别码也会一起返回。如果不需要结束状态值，则参数status可以设成 NULL.

```cpp
#include <stdio.h> 
#include <unistd.h> 
#include <stdlib.h> 
#include<sys/types.h> 
#include<sys/wait.h> 
 
int main() { 
    pid_t pc = fork(); //创建一个子进程 
    if (pc > 0){//父进程 
        printf("in parent process\n"); 
        //阻塞在这里，等待子进程退出 
        pid_t pchild = wait(NULL); 
        printf("catch a child process pid of %d\n", pchild); 
    } 
    else if (pc == 0){ 
        printf ("in child process, PID: %u, PPID: %u\n", getpid(), getppid());
        exit(0);//子进程退出 
    } 
    else { 
 
        printf("fork error!\n"); 
        exit(-1); 
    } 
    return 0; 
}
//运行结果:
in parent process
in child process, PID: 2812, PPID: 2811
catch a child process pid of 2812
```

从结果可以看到，我们成功捕获了子进程的PID，最后子进程将销毁，资源得到释放。

**waitpid()**功能与wait相同，但可指定pid进程清理，可以不阻塞。原型如下

```cpp
#include <sys/types.h> 
#include <sys/wait.h> 
 
pid_t waitpid(pid_t pid, int *status, in options); 
//成功：返回清理掉的子进程ID；失败：-1(无子进程)
```

1. 特殊参数和返回情况，参数pid：

   \> 0回收指定ID的子进程

   -1回收任意子进程（相当于wait）

   0回收和当前调用waitpid一个组的所有子进程

   < -1回收指定进程组内的任意子进程

2. 参数status：

   子进程的结束状态值会由参数status返回，而子进程的进程识别码也会一起返回。如果不需要结束状态值，则参数status可以设成 NULL。

3. 参数options：

   Options=WNOHANG时，如果使用了WNOHANG(wait no hung)参数调用waitpid，即使没有子进程退出，它也会立即返回，不会像wait那样永远等下去。

   Options=WUNTRACED时，则子进程进入暂停则马上返回，但结束状态不予以理会。

   如果不想使用，Options=0

注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。

```cpp
#include <sys/types.h> 
#include <sys/wait.h> 
#include <unistd.h> 
#include <stdio.h> 
#include <stdlib.h> 
 
int main(void){ 
    pid_t pid = fork(); 
 
    if (pid < 0) { 
        perror("fork error!\n"); 
        exit(-1); 
    } 
    if (pid == 0) { 
        for (int i=4; i>0; --i) { 
            printf("This is the child\n"); 
            sleep(2); 
        } 
        exit(32); 
    }  
 
    else { 
        int stat_val; 
        waitpid(pid, &stat_val, 0);//0阻塞 
        if (stat_val)  //stat_val为传出参数 
            printf("Child exited with code %d\n", stat_val); 
        else if (stat_val) 
            printf("Child terminated abnormally, signal %d\n", stat_val); 
    } 
    return 0; 
}
//运行结果如下:
This is the child
This is the child
This is the child
This is the child
Child exited with code 8192
//子进程打印了4次信息后被回收，waitpid成功捕获了子进程，结束状态也一并打印出来了
```

#### 说说sleep和wait的区别？

（1）sleep是一个延时函数，让进程或线程进入休眠。休眠完毕后继续运行。

（2）wait是父进程回收子进程PCB（Process Control Block）资源的一个系统调用。

#### 线程池设计思路、线程池中线程的数量有什么决定

**为什么要创建线程池？**

​		创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。 这样**频繁**的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。同时线程池也是为了**提升系统效率**。

实现线程池有以下几个步骤：

（1）设置一个生产者消费者队列，作为临界资源。

（2）初始化n个线程，并让其运行起来，加锁去队列里取任务运行

（3）当任务队列为空时，所有线程阻塞。

（4）当生产者队列来了一个任务后，先对队列加锁，把任务挂到队列上，然后使用条件变量去通知阻塞中的一个线程来处理。

**线程池中线程数量**：

线程数量和哪些因素有关：CPU，IO、并行、并发

```shell
如果是CPU密集型应用，则线程池大小设置为：CPU数目+1
如果是IO密集型应用，则线程池大小设置为：2*CPU数目+1
最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目
```

所以线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。

**线程池的核心线程与普通线程：**

任务队列可以存放100个任务，此时为空，线程池里有10个核心线程，若突然来了10个任务，那么刚好10个核心线程直接处理；若又来了90个任务，此时核心线程来不及处理，那么有80个任务先入队列，再创建核心线程处理任务；若又来了120个任务，此时任务队列已满，不得已，就得创建20个普通线程来处理多余的任务。
**以上是线程池的工作流程。**

#### **虚拟内存技术**

虚拟内存是一种**内存管理技术**。虚拟内存技术使得不同的进程在运行过程中，它所看到的是自己独占的4G内存空间。所有进程**共享**同一物理内存，每个进程只把自己的虚拟内存空间**映射**并存储到物理内存上

**为什么要使用虚拟内存**

> （1）进程地址空间不隔离。会导致数据被随意修改。
>
> （2）内存使用效率低。
>
> （3）程序运行的地址不确定。操作系统随机为进程分配内存空间，所以程序运行的地址是不确定的。

**虚拟内存的好处：**

（1）扩大地址空间。每个进程独占一个4G空间，虽然真实物理内存没那么多。

（2）内存保护：防止不同进程对物理内存的争夺和践踏，可以对特定内存地址提供写保护，防止恶意篡改。

（3）可以实现内存共享，方便进程通信。

（4）可以避免内存碎片，虽然物理内存可能不连续，但映射到虚拟内存上可以连续。

虚拟内存的代价：

（1）虚拟内存需要额外构建数据结构，占用空间。

（2）虚拟地址到物理地址的转换，增加了执行时间。

（3）页面换入换出耗时。

（4）一页如果只有一部分数据，浪费内存。

**有关概念：**

（1）**分页和页表：**虚拟内存是操作系统里的概念，对操作系统来说，**虚拟内存就是一张张的对照表**；

系统里的基本单位都是 Byte 字节，**如果将每一个虚拟内存的 Byte 都对应到物理内存的地址，每个条目最少需要 4字节（32位虚拟地址->32位物理地址），在 4G 内存的情况下，就需要 16GB 的空间来存放对照表**。

**在系统启动时，操作系统将整个物理内存以** **4K** **为单位，划分为各个页。之后进行内存分配时，都以页为单位，**那么虚拟内存页对应物理内存页的映射表就大大减小了，4G 内存，32位操作系统虚拟地址空间是2^32，假设每页分为4k，需要 `(2^32/(4*2^10))*4 = 4M`的空间，

**操作系统虚拟内存到物理内存的映射表，就被称为页表。**

（2）**内存寻址和分配**：我们知道通过虚拟内存机制，每个进程都以为自己占用了全部内存，进程访问内存时，操作系统都会把进程提供的虚拟内存地址转换为物理地址，再去对应的物理地址上获取数据。

CPU 中有一种硬件，内存管理单元 **MMU**（Memory Management Unit）专门用来将翻译虚拟内存地址。CPU 还为页表寻址设置了缓存策略，由于程序的局部性，其缓存命中率能达到 98%。

以上情况是页表内存在虚拟地址到物理地址的映射，而如果进程访问的物理地址还没有被分配，系统则会产生一个缺页中断，在中断处理时，系统切到内核态为进程虚拟地址分配物理地址。

操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫**页表。页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。**、

（3）**虚拟内存寻址**（三级页表机制）

1）逻辑地址转线性地址：段起始地址+段内偏移地址=线性地址

2）线性地址转物理地址：

每一个32位的线性地址被划分为三部分：页目录索引（10位）、页表索引（10位）、页内偏移（12位）

- 从cr3中取出进程的页目录地址（操作系统调用进程时，这个地址被装入寄存器中）
- 页目录地址 + 页目录索引 = 页表地址
- 页表地址 + 页表索引 = 页地址
- 页地址 + 页内偏移 = 物理地址

![img](https://i.loli.net/2021/04/20/Aus5K4oMhUR7rHz.png)

#### 缺页中断

首先我们先弄清**缺页异常**：malloc和mmap函数在分配内存时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个**缺页异常**

**缺页中断：**缺页异常后将产生一个缺页中断，此时操作系统会根据页表中的外存地址在**外存**中找到所缺的一页，将其调入**内存**。

##### 缺页中断与一般中断的区别

缺页中断与一般中断一样，需要经历四个步骤：保护CPU现场、分析中断原因、转入缺页中断处理程序、恢复CPU现场，继续执行。

缺页中断与一般中断区别：

（1）在指令执行期间产生和处理缺页中断信号

（2）一条指令在执行期间，可能产生多次缺页中断

（3）缺页中断返回的是执行产生中断的一条指令，而一般中断返回的是执行下一条指令。

#### 缺页置换算法

先进先出（First In First Out, **FIFO**）算法：队列，删除队首的页即可

最近最久未使用置换（Least Recently Used，**LRU**）算法：置换最近一段时间以来最长时间未访问的页面。

最近最少使用（Least Frequently Used，**LFU**）算法：置换最近一段时间以来访问频率最低的页面。

LRU：用于**缓存淘汰**。**思路**是将缓存中**最近最少使用**的对象删除掉。**实现方式**是利用**链表**和**哈希表**。

**具体的做法**是：当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。

在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。

##### LRU设计实现

```cpp
class LRUCache {  
    list<pair<int, int>> cache;//创建双向链表  
    unordered_map<int, list<pair<int, int>>::iterator> map;//创建哈希表  
    int cap;  
public:  
    LRUCache(int capacity) {  
        cap = capacity;  
    }  

    int get(int key) {  
        if (map.count(key) > 0){  
            auto temp = *map[key];  //注意这里是取出迭代器中的元素
            cache.erase(map[key]);  
            map.erase(key);  
            cache.push_front(temp);//把该节点移到链表头部  
            map[key] = cache.begin();//映射头部  
            return temp.second;  
        }  
        return -1;  
    }  

    void put(int key, int value) {  
        if (map.count(key) > 0){  
            cache.erase(map[key]);  
            map.erase(key);  
        }  
        else if (cap == cache.size()){//若缓存满了，则把链表最后一个节点删除  
            auto temp = cache.back();  
            map.erase(temp.first);  
            cache.pop_back();  
        }  
        cache.push_front(pair<int, int>(key, value));//新建一个节点，放到链表头部 
        map[key] = cache.begin();//映射头部  
    }  
};  
/** 
Your LRUCache object will be instantiated and called as such: 
LRUCache* obj = new LRUCache(capacity); 
int param_1 = obj->get(key); 
obj->put(key,value); 
*/ 
```



#### 最佳置换算法、LRU、FIFO缺页率的计算

对于最佳置换页面算法：为右边最远的元素需要置换；

LRU:为左边最远的元素需要置换；

FIFO：为左边最长的元素需要被置换；

![image-20210406194357071](https://i.loli.net/2021/04/06/wELaf5tFIBrjm87.png)

#### 锁

所谓的**锁**，其实就是一个**变量**，拥有两种状态：1表示空闲状态，0表示上锁状态。加锁时，判断锁是否空闲，如果空闲，修改为上锁状态，返回成功；如果已经上锁，则返回失败。解锁时，则把锁状态修改为空闲状态

加锁过程可以表示为：（1）读锁。（2）判断锁状态。（3）如果已加锁，失败返回。（4）把锁设置为加锁状态。（5）返回成功。

虽然每一步是原子性的，但是每一步之间却是可以中断的。比如进程A在执行完2后发生中断，中断中进程B也执行了加锁过程，返回中断后就会发生两个进程都会加锁。

对于这个问题，计算机已经解决，方法是采用原子级汇编指令test and set 和swap。两个指令为原子操作。

（1）**互斥锁**：mutex，保证在任何时刻，都只有一个线程访问该资源，当获取锁操作失败时，线程进入睡眠，等待锁释放时被唤醒。

（2）**读写锁**：rwlock，分为读锁和写锁，处于读操作时，可以运行多个线程同时读。但写时同一时刻只能有一个线程获得写锁。

**互斥锁和读写锁的区别：**

（a）读写锁区分读锁和写锁，而互斥锁不区分

（b）互斥锁同一时间只允许一个线程访问，无论读写；读写锁同一时间只允许一个线程写，但可以多个线程同时读。

（3）**自旋锁**：spinlock，在任何时刻只能有一个线程访问资源。但获取锁操作失败时，不会进入睡眠，而是原地自旋，直到锁被释放。**这样节省了线程从睡眠到被唤醒的时间消耗，提高效率。**

（4）**条件锁**：就是所谓的**条件变量**，某一个线程因为某个条件未满足时可以使用条件变量使该程序处于阻塞状态。一旦条件满足了，即可唤醒该线程(常和互斥锁配合使用)

（5）**信号量**。

##### 死锁

是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种**互相等待**的现象。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。两只羊过独木桥。进程比作羊，资源比作桥。若两只羊互不相让，争着过桥，就产生死锁

**产生死锁的必要条件**

（1）**互斥条件**：进程对所分配到的资源不允许其他进程访问，若其他进程访问，只能等待，直到占有该资源的进程使用完成后释放该资源；

（2）**请求保持条件**：进程获得一定资源后，又对其他资源发出请求，但该资源被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源；

（3）**不可剥夺条件**：进程已获得的资源，只能自己释放，不可剥夺；

（4）**环路等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系。存在一个进程等待序列{P1，P2，…，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一 源，……，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。

**解决办法**：

（1）资源一次性分配，从而解决请求保持的问题

（2）可剥夺资源：当进程新的资源未得到满足时，释放已有的资源；

（3）资源有序分配：资源按序号递增，进程请求按递增请求，释放则相反。

> 1. 按顺序加锁
> 2. 增加超时检测：一定时间没有拿到，
> 3. 死锁检测

#### **操作系统资源调度算法**

进程调度算法：先来先服务，高响应比优先，短任务优先，抢占式短任务优先，时间片轮转算法、多级反馈队列调度算法。

其中先来先服务、高响应比优先都不会出现饥饿现象。

#### 5种IO模型

阻塞I/O，非阻塞IO，IO复用、信号驱动式IO，异步IO；前四种为同步IO；

1. **同步与异步的区别**：

   **同步**：所有的操作都做完，才返回给用户结果。即**写完数据库**之后，**再响应用户**，用户体验不好。双方的动作是经过双方协调的，步调一致的。

   **异步**：不用等所有操作都做完，就响应用户请求。即**先响应用户请求**，然后**慢慢去写数据库**，用户体验较好。双方并不需要协调，都可以随意进行各自的操作。

2. **阻塞与非阻塞的区别**：

   **阻塞**：调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。

   **非阻塞**：非阻塞等待，每隔一段时间就去检查IO事件是否就绪。没有就绪就可以做其他事情。

```
 同步IO：用户进程发出IO调用，去获取IO设备数据，双方的数据要经过内核缓冲区同步，完全准备好后，再复制返回到用户进程。而复制返回到用户进程会导致请求进程阻塞，直到I/O操作完成。

异步IO：用户进程发出IO调用，去获取IO设备数据，并不需要同步，内核直接复制到进程，整个过程不导致请求进程阻塞
```

```
POSIX(可移植操作系统接口)把同步IO操作定义为导致进程阻塞直到IO完成的操作，反之则是异步IO
```

##### IO模型

​		这里统一使用Linux下的系统调用recv作为例子，它用于从套接字上接收一个消息，因为是一个系统调用，所以调用时会**从用户进程空间切换到内核空间运行一段时间再切换回来**。默认情况下recv会等到网络数据到达并且复制到用户进程空间或者发生错误时返回，而第4个参数flags可以让它马上返回。

- **阻塞IO模型**

  使用recv的默认参数一直等数据直到拷贝到用户空间，这段时间内进程始终阻塞。A同学用杯子装水，打开水龙头装满水然后离开。这一过程就可以看成是使用了阻塞IO模型，因为如果水龙头没有水，他也要等到有水并装满杯子才能离开去做别的事情。很显然，这种IO模型是同步的。

  进程发起IO**系统调用**后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。调用者将一直等待，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作

  ![image](..\Study_Notes\图片\阻塞io)

  

- **非阻塞IO模型**

  ​		改变flags，让recv不管有没有获取到数据都返回，如果没有数据那么一段时间后再调用recv看看，如此循环。B同学也用杯子装水，打开水龙头后发现没有水，它离开了，过一会他又拿着杯子来看看……在中间离开的这些时间里，B同学离开了装水现场(回到用户进程空间)，可以做他自己的事情。这就是非阻塞IO模型。但是它只有是检查无数据的时候是非阻塞的，在数据到达的时候依然要等待复制数据到用户空间(等着水将水杯装满)，因此它还是同步IO；

  进程发起IO**系统调用**后，进程被阻塞，内核数据还没好，不想让进程等待，就返回一个错误，这样进程就不阻塞了。进程每隔一段时间就发起IO系统调用去检查IO事件是否就绪。这样就实现非阻塞了。每个进程都有一个时间片，轮询的时候读取IO，时间片到了就要换另一个进程做其他事情了，这样就做到了每隔一段时间发起IO系统调用。

  ![image](..\Study_Notes\图片\非阻塞IO)

  对于上面的阻塞IO模型来说，内核数据没准备好**需要进程阻塞的时候，就返回一个错误，以使得进程不被阻塞。**

  1、典型应用：socket是非阻塞的方式（设置为NONBLOCK）

  2、特点：
  
  > **进程轮询（重复）调用，消耗CPU的资源**；
  >
  > 实现难度低、开发应用相对阻塞IO模式较难；
>
  >  适用并发量较小、且不需要及时响应的网络应用开发；

  - ###### I/O复用机制

  这里在调用recv前先调用select或者poll，这2个系统调用都可以在内核准备好数据(网络数据到达内核)时告知用户进程，这个时候再调用recv一定是有数据的。因此这一过程中它是==阻塞于select或poll==，而没有阻塞于recv，有人将非阻塞IO定义成在读写操作时没有阻塞于系统调用的IO操作(不包括数据从内核复制到用户空间时的阻塞，因为这相对于网络IO来说确实很短暂)，如果按这样理解，这种IO模型也能称之为非阻塞IO模型，但是按POSIX来看，它也是同步IO，那么也和楼上一样称之为同步非阻塞IO吧。

  这种IO模型比较特别，分个段。因为它能同时监听多个文件描述符(fd)。这个时候C同学来装水，发现有一排水龙头，舍管阿姨告诉他这些水龙头都还没有水，等有水了告诉他。于是等啊等(select调用中)，过了一会阿姨告诉他有水了，但不知道是哪个水龙头有水，自己看吧。于是C同学一个个打开，往杯子里装水(recv)。这里再顺便说说鼎鼎大名的epoll(高性能的代名词啊)，epoll也属于IO复用模型，主要区别在于舍管阿姨会告诉C同学哪几个水龙头有水了，不需要一个个打开看(当然还有其它区别)。

  ![image](..\Study_Notes\图片\IO复用机制)

  - **信号驱动IO模型**

  通过调用sigaction注册信号函数，等内核数据准备好的时候系统中断当前程序，执行信号函数(在这里面调用recv)。D同学让舍管阿姨等有水的时候通知他(注册信号函数)，没多久D同学得知有水了，跑去装水。是不是很像异步IO？很遗憾，它还是同步IO(省不了装水的时间啊)。

   当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。

  ![image](E:\Study_Notes\图片\信号驱动IO)

  - **异步IO模型**

  调用aio_read，让内核等数据准备好，并且复制到用户进程空间后执行事先指定好的函数。E同学让舍管阿姨将杯子装满水后通知他。整个过程E同学都可以做别的事情(没有recv)，这才是真正的异步IO。

  进程发起IO**系统调用**后立即返回，**当内核将数据拷贝到缓冲区后，再通知应用程序。用户可以直接去使用数据**。具体操作是进程调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回。

  ![image](E:\Study_Notes\图片\异步IO)

  - **IO模型比较**

    ![image-20210315162847754](E:\Study_Notes\图片\模型比较·)

  前四种属于同步IO，原因就在于进程发起IO**系统调用**读取数据时，这个真正拿到数据的过程依然是阻塞的，直到完成数据读取还要把数据拷贝到用户空间中，进程才能继续做其他事。
  而异步IO就不一样了，进程完全做自己的事情，数据都不需要它读取，而是由内核读取数据并将数据拷贝到缓冲区后，再通知应用程序。用户可以直接去使用数据。

  IO分两阶段：

  ```
  1.数据准备阶段
  2.内核空间复制回用户进程缓冲区阶段
  ```

  一般来讲：阻塞IO模型、非阻塞IO模型、IO复用模型(select/poll/epoll)、信号驱动IO模型都属于同步IO，因为阶段2是阻塞的(尽管时间很短)。只有异步IO模型是符合POSIX异步IO操作含义的，不管在阶段1还是阶段2都可以干别的事；

### Select、poll和Epoll的区别

**I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作**。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个**读写过程是阻塞的**，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间，用户直接使用数据，这个过程是**非阻塞的**

1、select

```cpp
int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
//n为fdset集合中最大描述符值加1，fdset是一个位数组(文件描述符集合)，大小限制为1024，位数组每一位代表了其对应的描述符是否需要被检查：

```

> 1、每次调用内核的select函数，都会涉及用户态和内核态的切换，还需要传递需要检查的fd-set集合
>
> select函数被调用之后，首先会去fd集合中去检查内存中socket套接字的状态，这个时间复杂度是O(N)的，然后检查完一遍之后，如果有就绪状态的socket，那么直接返回，不会发生阻塞；否则说明当前指定的fd集合对应的socket没有就绪状态，那么就需要阻塞调用当前进程/线程，直到有某个socket有数据之后，才会唤醒线程；
>
> 完成两件事：第一件事，跑到就绪状态的socket对应的fd文件中设置一个标记mask，表示这个fd对应的socket已经就绪，第二件事，返回select函数，对应的就是唤醒进程，返回一个int的结果值，表示有几个socket处于就绪状态。但是具体那个socket就绪是不知道的，接下来会以O(n)的系统调用，检查fd集合中每个socket的就绪状态。
>
> 1024限制：因为fd集合这个结构的本质是一个bitmap位图的结构，长的二进制数，默认长度是1024,系统调用涉及参数的数据拷贝，如果数据庞大，不利于系统调用。

select函数监视文件描述符，调用后select函数会阻塞，直到有描述符就绪，或者超时，函数返回，当select函数返回后，就可以==遍历描述符，找到就绪的描述符==。

　　　select的一个缺点在于单个进程能够监视的文件描述符的数量也存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制。但是这样也会造成效率的降低。

2、poll

```cpp
int poll (struct pollfd *fds, unsigned int nfds, int timeout);
```

　　　不同与select使用==三个位图（bitmap)来表示三个fdset==的方式，poll使用 pollfd的指针（链表结构）实现

​			没有最大限制（但是数量过大后性能也是会下降）。和select函数一样，==poll返回后，需要轮询来获取就绪的描述符==。

**select的缺陷**

> （1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大
>
> （2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大
>
> （3）select支持的文件描述符数量太小了，默认是1024

**select和poll共有缺陷：**

对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要执行一个系统调用

> 第一个缺陷：select和poll函数，这两个系统调用函数每次都要我们提供给他所有需要监听的socket文件描述符集合，主线程死循环调用selct/poll函数，这里面涉及到用户空间数据到内核空间的拷贝。
>
> 第二个缺陷：返回的int整型，进程被唤醒之后还需要新一轮的系统调用去检查那个socket是就绪状态，

　　	select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。

3、epoll

​		相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。

```cpp
int epoll_create(int size);
/*内核会产生一个epoll 实例数据结构并返回一个文件描述符，这个特殊的描述符就是epoll实例的句柄，后面的两个接口都以它为中心（即epfd形参）。
size参数表示所要监视文件描述符的最大值，不过在后来的Linux版本中已经被弃用
*/
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
//将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
//参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。
```

epoll_wait函数

> 返回值int整型
>
> - 返回0，表示没有就绪的socket
> - 返回大于0，表示有几个就绪的socket
> - 返回-1，表示异常
>
> 调用的时候传入一个epoll_event的事件数组指针，函数正常返回之前，会把就绪的socket事件信息拷贝到这个数组指针里面，通过这个数组就可以拿到就绪列表;、
>
> 默认epoll_wai是阻塞的，有一个参数可以设置为0，非阻塞调用，-1永久阻塞
>
> 每次调用都会去检查就序列表。

对于第一个缺点，epoll把所有的fd拷贝进**共享内存**中，内核可以直接访问。这样epoll保证了每个fd在整个过程中只会拷贝一次。

对于第二个缺点，epoll的解决方案不像select或poll一样每次都把当前进程轮流挂到不同的设备上（也即fd_set），而只在 epoll_ctl时把当前进程挂一遍（这一遍必不可少）并为每个fd指定一个回调函数（每一个设备对应一个回调函数，不用再轮询了，效率也就高了），**当设备数据就绪时**，唤醒等待队列上的等待者，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表。**epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd，只要判断一下就绪链表是否为空就行了**。

对于第三个缺点，epoll没有这个限制，它所支持的fd上限是最大可以打开文件的数目，这个数字一般远大于2048。

三者的区别总结：

（1）poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。

（2）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。

（3）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而epoll只要一次拷贝，而且把当前进程往等待队列上挂也只挂一次，这也能节省不少的开销。

### Epoll的实现原理

首先创建一个epoll对象，然后使用epoll_ctl对这个对象进行操作（添加、删除、修改），把需要监控的描述符加进去，这些描述符将会以**epoll_event结构体**的形式组成一颗**红黑树（说明查询的复杂度降为logn了）**，接着阻塞在**epoll_wait**，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入一个**链表**中，返回有事件发生的链表，用户再遍历这个链表查看具体是哪个事件。流程如下图：

​		当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关，如下所示：

```cpp
struct eventpoll {
　　...
　　/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，
　　也就是这个epoll监控的事件*/
　　struct rb_root rbr;
　　/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/
　　struct list_head rdllist;
　　...
};
```

​		eventpoll结构体，有三块重要的区域：

> 1. 红黑树：存放需要监听的socket_fd描述符列表，
> 2. 另一块就是==就序列表==，存放就绪状态的socket信息；
> 3. eventpoll==等待队列==链表，保存调用epoll_wait的进程
>
> **wq：** 等待队列链表。，用来保存对某一个 epoll 实例调用 epoll_wait()的所有进程，软中断数据就绪的时候会通过 wq 来找到阻塞在 epoll 对象上的用户进程，唤醒等待队列中的进程执行用户态的业务逻辑。
>
> **rbr：** 一棵红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll 内部使用了一棵红黑树。通过这棵树来管理用户进程下添加进来的所有 socket 连接。
>
> **rdllist：** 就绪的描述符的链表。当有的连接就绪的时候，内核会把就绪的连接放到 rdllist 链表里。这样应用进程只需要判断链表就能找出就绪进程，而不用去遍历整棵树。

我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个rdllist双向链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个rdllist双向链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。

==一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题==。

- 执行epoll_create()时，创建了红黑树（查找时间复杂度O(logn))和就绪链表；


- 执行epoll_ctl()时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据；
- 执行epoll_wait()时立刻返回准备就绪链表里的数据即可

#### 1. 是否所有的文件类型都可以被epoll监视

> 不是，只有底层驱动实现了 file_operations 中 poll 函数的文件类型才可以被 epoll 监视！socket类型的文件驱动是实现了 poll 函数的，因此才可以被 epoll 监视

#### Epoll惊群效应



### epoll的LT和ET工作模式



epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：

- LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，`应用程序可以不立即处理该事件`。下次调用epoll_wait时，==会再次响应应用程序并通知此事件==。

- ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，`应用程序必须立即处理该事件=`。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。

> **LT（水平触发）模式下**，只要这个文件描述符还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作；
>
> **ET（边缘触发）模式下**，在它检测到有 I/O 事件时，通过 epoll_wait 调用会得到有事件通知的文件描述符，对于每一个被通知的文件描述符，如可读，则必须将该文件描述符一直读到空，让 errno 返回 EAGAIN 为止，否则下次的 epoll_wait 不会返回余下的数据，会丢掉事件。==如果ET模式不是非阻塞的，那这个一直读或一直写势必会在最后一次阻塞。==

#### 1. LT模式

LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。

#### 2. ET模式

ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)

ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用==非阻塞套接口，以避免由于一个文件描述符的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死==。

![image-20210315225451408](..\Study_Notes\图片\epoll的ET和LT模式)

- LT 模式（水平触发，默认）**只要有数据都会触发**，缓冲区剩余未读尽的数据会导致epoll_wait返回。
- ET模式（边缘触发）**只有数据到来才触发**，**不管缓存区中是否还有数据**，缓冲区剩余未读尽的数据不会导致epoll_wait返回；

#### UDP需要LT和ET吗？为什么？

> TCP是可靠传输，所以数据一定要读完，采用ET时一定要循环读，而且时非阻塞的，但是UDP不保证可靠性，数据可以直接被丢弃。

##### Reactor模式

​		要求主线程（I/O处理单元）只==负责监听文件描述符上是否有事件发生==，有的话就立即将该事件通知工作线程（逻辑单元）,除此之外，主线程不做任何其他实质性的工作。==读写数据，接受新的连接以及处理客户请求均在工作线程中完成==

![image-20210310193912893](https://s2.loli.net/2022/04/12/R5EJbiuAI9cN6Ok.png)

##### Proactor模式

这种模式将所有的I/O操作都交给==主线程和内核==来处理，==工作线程仅仅负责业务逻辑==，

![image-20210310194652609](https://s2.loli.net/2022/04/12/Qg6V4F9djIltzrY.png)



## 计算机网络

### 计算机网络体系结构：

![计算机网络体系结构](E:\Study_Notes\图片\计算机网络体系结构.png)

**分层模型结构**：

> **OSI七层模型**：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层（无数王传徽标应）
>
> **TCP/IP四层（五层）模型**：物理层、数据链路层、网路层、传输层、应用层。

常见协议：

> 传输层：TCP/UDP
>
> 应用层：HTTP、FTP、NFS、SSH、telnet
>
> 网络层：IP、ICMP、IGMP
>
> 网络接口层：ARP、RARP
>
> 链路层：以太网帧协议、ARP

### 各层作用及协议

**应用层**的数据称为**报文（message）**；在**传输层**的数据称为**段（segment）**；在**网络层**的数据叫 **分组包（packet）**，**网络接口层（链路层）**的数据称为**帧（frame）**。

|    分层    |                        作用                         |                        协议                         |
| :--------: | :-------------------------------------------------: | :-------------------------------------------------: |
|   物理层   |  通过媒介传输比特，确定机械及电气规范（比特 Bit）   |      RJ45、CLOCK、IEEE802.3（中继器，集线器）       |
| 数据链路层 |      将比特组装成帧和点到点的传递（帧 Frame）       |      PPP、FR、HDLC、VLAN、MAC（网桥，交换机）       |
|   网络层   |   负责数据包从源到宿的传递和网际互连（包 Packet）   | IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器） |
|   运输层   |  提供端到端的可靠报文传递和错误恢复（ 段Segment）   |                    TCP、UDP、SPX                    |
|   会话层   |    建立、管理和终止会话（会话协议数据单元 SPDU）    |               NFS、SQL、NETBIOS、RPC                |
|   表示层   | 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） |                  JPEG、MPEG、ASII                   |
|   应用层   |   允许访问OSI环境的手段（应用协议数据单元 APDU）    |       FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS        |

#### 物理层

- 传输数据的单位：比特
- 数据传输系统：源系统（源点、发送器） --> 传输系统 --> 目的系统（接收器、终点）

通道：

- 单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播
- 双向交替通信（半双工通信）：通信双方都可发消息，但不能同时发送或接收
- 双向同时通信（全双工通信）：通信双方可以同时发送和接收信息

通道复用技术：

- **频分复用**（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源
- 时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度
- 波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用
- 码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信

#### 数据链路层

主要信道：

- 点对点信道
- 广播信道

**点对点信道**

- 数据单元：帧

三个基本问题：

- 封装成帧：把网络层的 IP 数据报封装成帧，`SOH - 数据部分 - EOT`
- 透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符）
- 差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check）

点对点协议（Point-to-Point Protocol）：

- 点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议

**广播信道**

广播通信：

- 硬件地址（物理地址、MAC 地址）
- 单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同
- 广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧
- 多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧

#### 网络层

- IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。
- ARP（Address Resolution Protocol，地址解析协议）
- ICMP（Internet Control Message Protocol，网际控制报文协议）
- IGMP（Internet Group Management Protocol，网际组管理协议）

**IP 网际协议**

IP 地址分类：

- `IP 地址 ::= {<网络号>,<主机号>}`

| IP 地址类别 |                 网络号                 |        网络范围        | 主机号 |         IP 地址范围          |
| :---------: | :------------------------------------: | :--------------------: | -----: | :--------------------------: |
|    A 类     |          8bit，第一位固定为 0          |        0 —— 127        |  24bit |  1.0.0.0 —— 127.255.255.255  |
|    B 类     |         16bit，前两位固定为 10         |    128.0 —— 191.255    |  16bit | 128.0.0.0 —— 191.255.255.255 |
|    C 类     |        24bit，前三位固定为 110         | 192.0.0 —— 223.255.255 |   8bit | 192.0.0.0 —— 223.255.255.255 |
|    D 类     |   前四位固定为 1110，后面为多播地址    |                        |        |                              |
|    E 类     | 前五位固定为 11110，后面保留为今后所用 |                        |        |                              |

**IP 数据报格式：**

![IP 数据报格式](\Study_Notes\图片\IP数据报文)

**ICMP 网际控制报文协议**

ICMP 报文格式：

![img](\Study_Notes\图片\ICMP报文格式.png)

应用：

- PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性
- TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量

**内部网关协议**

- RIP（Routing Information Protocol，路由信息协议）
- OSPF（Open Sortest Path First，开放最短路径优先）

**外部网关协议**

- BGP（Border Gateway Protocol，边界网关协议）

**IP多播**

- IGMP（Internet Group Management Protocol，网际组管理协议）
- 多播路由选择协议

**VPN 和 NAT**

- VPN（Virtual Private Network，虚拟专用网）
- NAT（Network Address Translation，网络地址转换）

**路由表包含什么？**

1. 网络 ID（Network ID, Network number）：就是目标地址的网络 ID。
2. 子网掩码（subnet mask）：用来判断 IP 所属网络
3. 下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: `0.0.0.0`, Netmask: `0.0.0.0`）指向自治系统的出口。

根据应用和执行的不同，路由表可能含有如下附加信息：

1. 花费（Cost）：就是数据发送过程中通过路径所需要的花费。
2. 路由的服务质量
3. 路由中需要过滤的出/入连接列表

#### 传输层

**协议：**

- TCP（Transmission Control Protocol，传输控制协议）
- UDP（User Datagram Protocol，用户数据报协议）

端口：

| 应用程序 | FTP  | TELNET | SMTP | DNS  | TFTP | HTTP | HTTPS | SNMP |
| -------- | :--: | :----: | ---- | ---- | ---- | ---- | ----- | ---- |
| 端口号   |  21  |   23   | 25   | 53   | 69   | 80   | 443   | 161  |

##### TCP

- TCP（Transmission Control Protocol，传输控制协议）是一种**面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。**

**特征：**

- 面向连接
- 只能点对点（一对一）通信
- 可靠交互
- 全双工通信
- 面向字节流

###### **TCP 如何保证可靠传输：**

> 1. 应用数据被分割成 TCP 认为最适合发送的数据块。
> 2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
> 3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
> 4. TCP 的接收端会丢弃重复的数据。
> 5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
> 6. **拥塞控制：** 当网络拥塞时，减少数据的发送。
> 7. **ARQ协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
> 8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

> 1. **序列号、确认应答、超时重传**
>    数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序列号，序列号说明了它下一次需要接收的数据序列号，保证数据传输有序。如果发送方迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一段时间后进行重传。
>
> 2. **窗口控制**
>    TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。
>    使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；数据一旦丢失，接收端会一直提醒。
>
> 3. **拥塞控制**
>    如果把窗口定的很大，发送端连续发送大量的数据，可能造成网络的拥堵。为了防止拥堵，进行拥塞控制。
>
>    （1）**慢启动**：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到一次确认应答，将拥塞窗口大小*2
>
>    （2）**拥塞避免**：设置慢启动阈值，一般开始都设为65536。拥塞避免是只当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是+1
>
>    （3）**快恢复**：将报文段的超时重传看做拥塞，则一旦发生超时重传，我们就将阈值设为当前窗口大小的一半，并且窗口大小变为1，重新进入慢启动过程
>
>    （4）**快速重传**：3次重复确认应答，立即重传。

###### 请说说TCP的ACK机制，有什么好处？

由于通信过程的不可靠性，传输的数据不可避免的会出现丢失、延迟、错误、重复等各种状况，TCP协议为解决这些问题设计了一系列机制。这个机制的核心，就是发送方向接收方发送数据后，接收方要向发送方发送ACK（回执）。如果发送方没接收到正确的ACK，就会重新发送数据直到接收到ACK为止。

比如：发送方发送的数据序号是seq，那么接收方会发送seq + 1作为ACK，这样发送方就知道接下来要发送序号为seq + 1的数据给接收方了。

**TCP 报文结构**

![image-20201224200043183](..\Study_Notes\图片\TCP报文结构)

**TCP 首部**

![image-20201224200118805](..\Study_Notes\图片\TCP首部)

**TCP：状态控制码**（Code，Control Flag），占 6 比特，含义如下：

- URG：紧急比特（urgent），当 `URG＝1` 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。
- ACK：确认比特（Acknowledge）。只有当 `ACK＝1` 时确认号字段才有效，代表这个封包为确认封包。当 `ACK＝0` 时，确认号无效。
- PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。
- RST：复位比特(Reset)，当 `RST＝1` 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
- SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。
- FIN：终止比特(Final)，用来释放一个连接。当 `FIN＝1` 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接

##### UDP

- UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。

**特征：**

- 无连接
- 尽最大努力交付
- 面向报文
- 没有拥塞控制
- 支持一对一、一对多、多对一、多对多的交互通信
- 首部开销小

**UDP 报文结构**

![image-20201224200453357](..\Study_Notes\图片\UDP报文结构)

**UDP 首部**

![image-20201224200537655](..\Study_Notes\图片\UDP首部)

##### TCP 与 UDP 的区别

1. TCP 面向连接，UDP 是无连接的；
2. TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付
3. TCP 的逻辑通信信道是==全双工的可靠信道==；UDP 则是==不可靠信道==
4. 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信
5. TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）
6. UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）
7. TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节

##### 如何让UDP也变得可靠

> 加入TCP可靠机制。回答TCP保证可靠的机制即可

##### TCP 黏包问题

Nagle算法简单的说，当提交一端数据给TCP时，TCP并不立刻发送此段数据，而是等待一段时间，看看在等待期间是否还有要发送的数据，若有则会一次吧多段数据发送出去。

TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。

对于UDP，不会使用块的合并优化算法，不存在封包，再加上**UDP本身是一个“数据包“协议**，也就是两段数据是有界限的，我们上节讲过，**UDP头部是记录了数据的长度的**，这样对于接收端来说，就容易进行区分处理了。所以**UDP不会出现粘包问题**。

**原因**

> 1. 由Nagle算法造成的**发送端粘包**。Nagle算法是一种改善网络传输效率的算法，但也可能造成困扰。Nagle算法简单的说，当提交一端数据给TCP时，TCP并不立刻发送此段数据，而是等待一段时间，看看在等待期间是否还有要发送的数据，若有则会一次把多段数据发送出去。这就造成了粘包。
> 2. 接收端接收不及时造成的**接收端粘包**。TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时取出TCP的数据，就会造成TCP缓冲区中存放多段数据。

**解决**

- 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
- 包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。
- 在数据包之间设置边界，如添加特殊符号 `\r\n` 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 `\r\n`，则会误判为消息的边界。
- 使用更加复杂的应用层协议。

##### TCP 流量控制

**概念**

流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。

**方法**

利用可变窗口进行流量控制

![image-20201224201138425](..\Study_Notes\图片\可变窗口进行留下流量控制)

##### TCP 拥塞控制

**概念**

拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。

**方法**：**慢开始、拥塞避免、快速重传、快速恢复**

- 慢开始( slow-start )
- ![image-20201227212444465](https://s2.loli.net/2022/02/26/oDZR5jkQ9lpgqYL.png)
- 拥塞避免( congestion avoidance )
- ![image-20201227212953953](..\Study_Notes\拥塞避免1)
- ![image-20201227212758909](..\Study_Notes\拥塞避免)
- 快重传( fast retransmit )
- ![image-20201227213032119](..\Study_Notes\快速重传)
- 快恢复( fast recovery )
- ![image-20201227213122177](..\Study_Notes\快速恢复)

##### TCP 传输连接管理

###### TCP 三次握手建立连接

![image-20201228202437572](..\Study_Notes\三次握手)

【TCP 建立连接全过程解释】

1. Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
2. Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置1，ack=J+1，随机产生一个值seq=K，并将该数据包发给Client以确认连接请求，Server进入SYN_RCVD状态。
3. Client收到确认后，检测ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检测ack是否为K+1，ACK是否为1，如果正确则连接成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了

###### TCP 为什么要进行三次握手？

> 假如只进行两次握手，客户端发送连接请求后，会等待服务器端的应答。但是会出现的问题是，假如客户端的SYN迟迟没有到达服务器端，此时客户端超时后，会重新发送一次连接，假如重发的这次服务器端收到了，且应答客户端了，连接建立了。
>
> 但是建立后，第一个SYN也到达服务端了，这时服务端会认为这是一个新连接，会再给客户端发送一个ACK，这个ACK当然会被客户端丢弃。但是此时服务器端已经为这个连接分配资源了，而且服务器端会一直维持着这个资源，会造成资源浪费。**两次握手的问题在于服务器端不知道SYN的有效性**，所以如果是三次握手，服务器端会等待客户端的第三次握手，如果第三次握手迟迟不来，服务器端就会**释放相关资源**。

【答案一】因为==信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输==，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。

【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。

【答案三】为了==防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误==。

###### 三次握手的作用

> 1. 确认双方的接受能力、发送能力是否正常。
> 2. 指定自己的初始化序列号（ISN)，为后面的可靠传送做准备；
> 3. 如果是https协议的话，三次握手这个过程还会进行数字证书的验证以及加密密匙的生成；



###### TCP 四次挥手释放连接

![image-20201228202803695](..\Study_Notes\四次挥手)

【TCP 释放连接全过程解释】

1. 数据传输结束后，Client的应用进程发出连接释放报文段FIN，并停止发送数据，Client进入FIN_WAIT_1状态，此时Client依然可以接收Server发送来的数据。
2. Server接收到FIN后，发送一个ACK给Client，确认序号为收到的序号+1，Server进入CLOSE_WAIT状态。Client收到后进入FIN_WAIT_2状态。
3. 当Server没有数据要发送时，Server发送一个FIN报文，此时Server进入LAST_ACK状态，等待Client的确认。
4. Client收到Server的FIN报文后，给Server发送一个ACK报文，确认序列号为收到的序号+1。此时Client进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。

###### TCP 为什么要进行四次挥手？

【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？

【答案一】因为 TCP 是**全双工模式**，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。

【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）

【答案二】因为==客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送==。

【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？

【答案三】

1. 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。**若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。**
2. **防止已失效的连接请求报文段出现在本连接中**。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。

###### **TCP有限状态机**

![img](..\Study_Notes\TCP的有限状态机.png)

###### SYN泛洪攻击

有一个客户端请求连接，向服务器发送SYN，服务器接收了，于是为这个请求分配资源，等待客户端确认，但这个时候，客户端没有进行下一步操作了，这时服务器会超时释放资源；但这个客户端一直重复连接请求，但就是不进一步建立连接，只是一味发送SYN，而我们的服务器也不停为它分配资源；

A（攻击者）发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当这个服务器返回ACK以后，A不再进行确认，那这个连接就处在了一个挂起的状态，也就是半连接的意思，那么服务器收不到再确认的一个消息，还会重复发送ACK给A。

这样一来就会更加浪费服务器的资源。A就对服务器发送非法大量的这种TCP连接，由于每一个都没法完成握手的机制，所以它就会消耗服务器的内存最后可能导致服务器死机，就无法正常工作了。更进一步说，如果这些半连接的握手请求是恶意程序发出，并且持续不断，那么就会导致服务端较长时间内丧失服务功能——这样就形成了DoS攻击。这种攻击方式就称为SYN泛洪攻击。

**如何避免**

> （1）比如**降低SYN timeout时间**，使得主机尽快释放半连接的占用。
>
> （2）或者采用**SYN cookie设置**，就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被丢弃。Cookie是当浏览某网站时，由Web服务器置于硬盘上一个非常小的文本文件，用来记录用户ID，密码，浏览过的网页，停留时间等信息。当我们认为受到了攻击，合理的采用防火墙设置等外部网络进行拦截。
>
> （3）**使用长连接**。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。

主机系统设置具体怎么做呢？

设置linux系统参数：

1. `net.ipv4.tcp_syncookies = 1 `表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
2. `net.ipv4.tcp_tw_reuse = 1 `表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
3. `net.ipv4.tcp_tw_recycle = 1 `表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
4. `net.ipv4.tcp_fin_timeout `修改系默认的 TIMEOUT 时间

##### 什么是负载均衡？

> 当一台服务器的单位时间内的访问量越大时，服务器压力就越大，大到超过自身承受能力时，服务器就会崩溃。为了避免服务器崩溃，让用户有更好的体验，我们通过负载均衡的方式来分担服务器压力。
>
> **什么是负载均衡**：我们可以建立很多很多服务器，组成一个服务器集群，当用户访问网站时，先访问一个中间服务器，再让这个中间服务器在服务器集群中选择一个压力较小的服务器，然后将该访问请求引入该服务器。如此以来，用户的每次访问，都会保证服务器集群中的每个服务器压力趋于平衡，分担了服务器压力，避免了服务器崩溃的情况。
>
> **负载均衡有几种方式实现**
> （1）轮询（默认）
> 请求依次轮流往每个应用服务器上进行分配，分配策略比较简单。
> 缺点：不均匀，可能会出现，某些服务器接受的请求较重，负载压力重，有些负荷小，不可控。另外服务器之间需要进行session同步。
> （2）权重轮询（权重越高，进入的几率越大）
> 优点：可以根据情况进行调整。可控，仍然需要进行session同步。
> （3）IP-Hash
> 优点：采用hash的方式来映射服务器。无需进行session同步，固定IP会固定访问一台服务器。
> 缺点：恶意攻击，会造成某台服务器压垮。提供的服务不同，面向的地区不同，IP可能会出现集中，造成不均匀，不可控。
> （4）Fair
> 这种相当于自适应，会根据服务器处理请求的速度进行负载均衡分配。处理请求最早结束的，拿到下一个请求。看上去是不是很好。但是一般都不使用，说是考虑到网络不稳定因素。还有待研究。这种也需要进行session同步。
> （5）URL-Hash
> 这种是根据URL进行hash，这样某些请求永远打某台服务器。利于利用服务器的缓存，但是可能由于URL的哈希值分布不均匀，以及业务侧重造成某些服务器压力大，某些负荷低。这种也需要进行session同步。

#### 应用层

##### **DNS**

- DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个**分布式数据库，**能够使人更方便地访问互联网。DNS 使用 **TCP 和 UDP 端口 53**。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符

**域名：**

- `域名 ::= {<三级域名>.<二级域名>.<顶级域名>}`，如：`blog.huihut.com`

##### FTP

- FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，**提供交互式访问**，**双向传输**。
- TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定

##### TELNET

- TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。
- HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。
- SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。
- Socket **建立网络通信连接至少要一对端口号（Socket）**。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。

##### WWW

- WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问

###### URL

- URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address）

标准格式：

- `协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]`

完整格式：

- `协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]`

> 其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项
> 如：`https://github.com/huihut/interview#cc`

##### HTTP

HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。

##### hTTP协议报文

  **1.请求报文(请求行/请求头/请求数据/空行)**

​    请求行

​      求方法字段、URL字段和HTTP协议版本

​      例如：GET /index.html HTTP/1.1

​        get方法将数据拼接在url后面，传递参数受限

​      请求方法：

​        GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT

​    请求头(key value形式)

​      User-Agent：产生请求的浏览器类型。

​      Accept：客户端可识别的内容类型列表。

​      Host：主机地址

​    请求数据

​      post方法中，会把数据以key value形式发送请求

​    空行

​      发送回车符和换行符，通知服务器以下不再有请求头

  **2.响应报文(状态行、消息报头、响应正文)**

​    状态行

​    消息报头

​    响应正文

 

例如请求数据：

> 1 GET/sample.jspHTTP/1.1
>
> 2 Accept:image/gif.image/jpeg,*/*
>
> 3 Accept-Language:zh-cn
>
> 4 Connection:Keep-Alive
>
> 5 Host:localhost
>
> 6 User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
>
> 7 Accept-Encoding:gzip,deflate
>
> 8
>
> 9 username=jinqiao&password=1234

第一行为http请求行，包含方法，URI 和http版本

2-7为请求头，包含浏览器，主机，接受的编码方式和压缩方式

第8行表示一个空行 表示请求头结束 这个空行是必须的

第9行是数据体，比如是需要查询的信息。

http响应体由三部分组成：

http响应由三个部分组成分别是状态行，响应头，响应正文。

状态行是由：HTTP-Version+Status-Code+Reason-Phrase

比如：HTTP/1.1 200 ok

分别表示http版本 + 状态码 + 状态代码的文本描述

状态码：

 

| 1xx  | 指示信息–表示请求已接收，继续处理         |
| ---- | ----------------------------------------- |
| 2xx  | 成功–表示请求已被成功接收、理解、接受     |
| 3xx  | 重定向–要完成请求必须进行更进一步的操作。 |
| 4xx  | 客户端错误–请求有语法错误或请求无法实现。 |
| 5xx  | 服务器端错误–服务器未能实现合法的请求。   |

 

响应头：包含服务器类型，日期，长度，内容类型等

Server:Apache Tomcat/5.0.12

Date:Mon,6Oct2003 13:13:33 GMT

Content-Type:text/html

Last-Moified:Mon,6 Oct 2003 13:23:42 GMT

Content-Length:112

 响应正文响应正文就是服务器返回的HTML页面或者json数据

 

 

一个完整的Http请求过程：

https://www.cnblogs.com/engeng/articles/5959335.html





**请求方法**

|  方法   |                             意义                             |
| :-----: | :----------------------------------------------------------: |
|   GET   |              请求指定的页面信息，并返回实体主体              |
|  HEAD   | 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| OPTIONS |         请求一些选项信息，允许客户端查看服务器的性能         |
|  POST   | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改 |
|   PUT   |        从客户端向服务器传送的数据取代指定的文档的内容        |
| DELETE  |                   请求服务器删除指定的页面                   |
|  TRACE  |           回显服务器收到的请求，主要用于测试或诊断           |

**状态码**（Status-Code）

- 1xx：**表示通知信息，如请求收到了或正在进行处理**
  - 100 Continue：继续，客户端应继续其请求
  - 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议
- 2xx：**表示成功，如接收或知道了**
  - 200 OK: 请求成功
- 3xx：**表示重定向，如要完成请求还必须采取进一步的行动**
  - 301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替
- 4xx：**表示客户的差错，如请求中有错误的语法或不能完成**
  - 400 Bad Request: 客户端请求的语法错误，服务器无法理解
  - 401 Unauthorized: 请求要求用户的身份认证
  - 403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够）
  - 404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面
  - 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时
- 5xx**：表示服务器的差错，如服务器失效无法完成请求**
  - 500 Internal Server Error: 服务器内部错误，无法完成请求
  - 503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中
  - 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求

#### HTTP和HTTPS的区别

主要的加密方法分为两种：一种是**对称密钥加密**例如：DES、AES-GCM、ChaCha20-Poly1305等，一种是**非对称密钥加密**，例如：RSA、DSA、ECDSA、 DH、ECDHE

> **1**、**端口**：http端口号是 80； https端口号是 443
>
> **2、传输协议**：http是超文本传输协议，属于明文传输；https是安全的超文本传输协议，是经过SSL加密后的传输协议
>
> **3、安全性：**https使用了TLS/SSL加密，比http更加的安全
>
> **4、证书：**https需要申请ca证书
>
> 5、Https除了三次握手以外，还要进行ssl握手，协商加密使用对称密匙；

##### **HTTP的通信过程**

作为标准的C/S模型，http协议总是由客户端发起，服务器进行响应。

1、DNS解析，域名系统DNS将域名解析成IP地址

2、建立TCP连接，进行TCP的三次握手

3、浏览器发送请求

4、服务器响应浏览器，向浏览器发送数据

5、通信完成，TCP连接关闭

##### **HTTPS的通信过程**

https通信是建立在ssl连接层之上的请求和响应，客户端将加密组件发送到服务端，服务端进行匹配后将数字证书等信息发送到客户端，客户端进行证书验证，验证通过后使用非对称加密对数据的密钥进行协商，协商后得到对称的加密密钥，然后使用对称算法进行TCP链接，然后与客户端进行三次握手后，进行数据传输，传输完成后，四次挥手，断开链接，通信结束。

**通信过程如下** :

通过**非对称加密方式**获取**对称加密密钥**，使用**对称加密方式**通信

1、客户端和服务器端通过TCP建立连接，并发送https请求。

2、服务器响应请求，并将数字证书发送给客户端，数字证书包括公共秘钥、域名、申请证书的公司。

3、客户端收到服务器端的数字证书之后，会验证数字证书的合法性。

4、如果公钥合格，那么客户端会生成client key，一个用于进行对称加密的密钥，并用服务器的公钥对客户端密钥进行非对称加密。

5、客户端会再次发起请求，将加密之后的客户端密钥发送给服务器。

6、服务器接收密文后，会用私钥对其进行非对称解密，得到客户端秘钥。并使用客户端秘钥进行对称加密，生成密文并发送。

7、客户端收到密文，并使用客户端秘钥进行解密，获取数据。

1. **端口** ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。

2. **安全性和资源消耗：**

   HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。

   - 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
   - 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。

#### HTTP1.0、HTTP1.1、HTTP2.0区别

**HTTP1.0、HTTP1.1的区别**

1. **长连接(Persistent Connection)**：HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。
2. **节约带宽**：HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。
3. **HOST域**：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。
4. **缓存处理**：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

HTPP2.0的优化

> 1. **多路复用**允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。
> 2. **二进制分帧**：在应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。http1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑http2.0的协议解析决定采用二进制格式，实现方便且健壮。
> 3. **首部压缩**：http1.x的header由于cookie和user agent很容易膨胀，而且每次都要重复发送。http2.0使用encoder来减少需要传输的header大小
> 4. **服务端推送**：http2.0能通过push的方式将客户端需要的内容预先推送过去

#### HTTP长连接,短连接

在HTTP/1.0中默认使用短连接。也就是说**，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接**。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```cpp
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，**客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。**Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

#### Cookie的作用是什么?和Session有什么区别？

Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

**Cookie 一般用来保存用户信息** 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。

**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

Cookie 数据保存在**客户端(浏览器端)**，Session 数据保存在**服务器端**。

Cookie 存储在客户端中，而Session存储在服务器上，相对来说 **Session 安全性更高**。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。

#### URI和URL的区别是什么?

> - URI(Uniform Resource Identifier) 是统一资源标志符，可以**唯一标识一个资源。**
> - URL(Uniform Resource Location) 是**统一资源定位符**，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。
>
> URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

#### 在浏览器中输入url地址 ->> 显示主页的过程

1. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;
2. 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;
3. 浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
4. 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
5. 释放 TCP连接;
6. 浏览器解析html代码，并请求html代码中的资源，最后对页面进行渲染呈现给用户。

![img](..\Study_Notes\URL过程)

#### GET和POST区别

> 1. Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 
> 2.  Get传送的数据量较小，这主要是因为受URL长度限制，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。；Post传送的数据量较大，一般被默认为不受限制。    
> 3. Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。  
> 4.  Get执行效率却比Post方法好。Get是form提交的默认方法

> - GET在浏览器回退时是无害的，而POST会再次提交请求。
> - GET产生的URL地址可以被Bookmark，而POST不可以。
> - GET请求会被浏览器主动cache，而POST不会，除非手动设置。
> - ==GET请求只能进行url编码，而POST支持多种编码方式==。
> - GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
> - ==GET请求在URL中传送的参数是有长度限制的，而POST没有==。
> - ==对参数的数据类型，GET只接受ASCII字符（URL 是 HTTP 的一个首部。既然作为一个首部，那么根据约定，一定是 ASCII 字符的），而POST没有限制==。
> - ==GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息==。
> - ==GET参数通过URL传递，POST放在Request body中==。

GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）

#### 转发和重定向的区别 

> 转发（forward）：是服务器内部的动作，服务器直接转到其他url，使用其中的资源，这个过程客户端是不可见的，客户端请求的url不会发生变化。**过程：客户端发起http请求-->服务器接受http请求--->服务器内部调用方法完成请求处理和转发--->将请求的资源发送给客户端。转发时，服务器只能准发到统一web容器下的url，中间传递的自己容器的request**
>
> 重定向（redirect）：是客户端的操作，服务器返回目标地址给客户端，客户端去访问，那么客户端一开始的请求url就会发生变化。**过程：客户端发起http请求-->服务器接受http请求返回302状态码--->客户端看见是302状态码，重新发起http请求--->服务器处理请求给客户端响应**



#### TIME_WAIT和ClOSE_WAIT

常用命令`netstat -n |`

**TIME_WAIT**

- TIME_WAIT 是**主动关闭**链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。  由于TIME_WAIT 的时间会非常长，因此server端应尽量减少主动关闭连接。

**CLOSE_WAIT**

- CLOSE_WAIT是**被动关闭**连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。

**为什么需要 TIME_WAIT 状态？**

- 假设最终的ACK丢失，server将重发FIN，client必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果server认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，client必须进入 TIME_WAIT 状态，因为client可能面 临重发最终ACK的情形。

**为什么 TIME_WAIT 状态需要保持 2MSL 这么长的时间？**

- 如果 TIME_WAIT 状态保持时间不足够长(比如小于2MSL)，第一个连接就正常终止了。第二个拥有相同相关五元组的连接出现，而第一个连接的重复报文到达，干扰了第二个连接。**TCP实现必须防止某个连接的重复报文在连接终止后出现，**所以让TIME_WAIT状态保持时间足够长(2MSL)，连接相应方向上的TCP报文要么完全响应完毕，要么被 丢弃。建立第二个连接的时候，不会混淆。

#### 请描述下TCP协议和HTTP协议，以及两者的区别和关系？



## 数据库

#### 数据库的三大范式

**第一范式**（1NF）：数据表中的每一列（每个字段）必须是**不可拆分的最小单元**，也就是确保每一列的原子性；

**第二范式**（2NF）：满足1NF后，要求表中的所有列，**都必须依赖于同一个主键**，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；

**第三范式**（3NF）：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关；（如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键）

#### 为什么使用索引？

- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 帮助服务器避免排序和临时表
- 将随机IO变为顺序IO。
- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

#### 主键索引和非主键索引

​		主键索引和非主键索引是有区别的，主键索引存放的值是**整行字段的数据**，而非主键索引上存放的值不是整行字段的数据，而是存放**主键字段的值**

#### Innodb为什么要用自增id作为主键？

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE（optimize table）来重建表并优化填充页面

#### 为什么SQL语句执行很慢

一个 SQL 语句执行的很慢，我们要分两种

> 1、大多数情况下很正常，偶尔很慢，则有如下原因
>
> (1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。
>
> (2)、执行的时候，遇到锁，如表锁、行锁。
>
> 2、这条 SQL 语句一直执行的很慢，则有如下原因。
>
> (1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。
>
> (2)、数据库选错了索引。

#### 乐观锁与悲观锁（并发控制）、自旋锁、互斥锁

​		当程序中可能出现[并发](https://www.jianshu.com/p/e8d674931af4)的情况时，就需要保证在并发情况下数据的准确性，以此确保当前用户和其他用户一起操作时，所得到的结果和他单独操作时的结果是一样的。这种手段就叫做**并发控制**。并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。没有做好并发控制，就可能导致出现**脏读、幻读和不可重复读**的问题；

并发控制确保在多个事务同时存取数据库中同一数据时，不破坏事务的隔离性、一致性和数据库的统一性。

**乐观并发控制(乐观锁)和悲观并发控制（悲观锁）**是并发控制主要采用的技术手段。

**悲观锁：**

> 当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。
>
> 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）
>
> 这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。

**乐观锁：**

> 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在==更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现==。乐观锁适用于==多读，写比较少==的应用类型，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作；
>
> 工作方式：**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作**。
>
> 使用场合：乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以**只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。**
>
> - 版本号控制:获取version------>更新的时候比较version

其他还有什么锁？

**自旋锁**：所谓自旋锁，就是让该线程==等待==一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋），可以用while循环，最好使用	cpu提供的PAUSE实现。

**需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。**

原因（意义）：在用户态既可以完成加锁和解锁的操作；**避免核心态和用户态之间切换的消耗。**
　　如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗

**互斥锁：**和自旋锁不一样，互斥锁加锁失败后，线程会==释放CPU==给其他线程；

​		互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，**既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞**。

**对于互斥锁加锁失败而阻塞的现象，是由==操作系统内核==实现的**。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：

<img src="..\Study_Notes\图片\互斥锁" alt="img" style="zoom:50%;" />

互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是会存在较大的开销成本，有两次线程上下文切换的成本；

> - 当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；
> - 接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。

​		当两个线程是属于同一个进程，**因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**

**如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁**

**读写锁：**

读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。

所以，**读写锁适用于能明确区分读操作和写操作的场景，读写锁在读多写少的场景，能发挥出优势**。

读写锁的工作原理是：

- 当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，【读锁】是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。
- 但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。

所以说，**写锁是独占锁**，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而**读锁是共享锁**，因为读锁可以被多个线程同时持有。



读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。如下图

<img src="..\Study_Notes\图片\读优先锁" alt="img" style="zoom:50%;" />

​		而写优先锁是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取读锁。如下图：

<img src="..\Study_Notes\图片\写优先级锁" alt="img" style="zoom:50%;" />

读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。

写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。

既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。

**公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象**。

#### 数据库常见问题

- 为啥索引常用 B+ 树作为底层的数据结构

- 除了 B+ 树索引，你还知道什么索引

- 为啥推荐自增 id 作为主键，自建主键不行吗

  ```
  这种由于页分裂造成的调整必然导致性能的下降，尤其是以身份证作为主键的话，由于身份证的随机性，必然造成大量的随机结点中的插入，进而造成大量的页分裂，进而造成性能的急剧下降，那如果是以自增 id 作为主键呢，由于新插入的表中生成的 id 比索引中所有的值都大，所以它要么合到已存在的节点(元素个数未满)中，要么放入新建的节点中(如下图示)所以如果是以自增 id 作为主键，就不存在页分裂的问题了，推荐
  ```

- 什么是页分裂，页合并

- 怎么根据索引查找行记录

  ```
  可以看到，非叶子节点只存了索引值，只在最后一行才存放了行记录，这样极大地减小了索引了大小，而且只要找到索引值就找到了行记录，也提升了效率，
  
  这种在叶节点存放一整行记录的索引被称为聚簇索引，其他的就称为非聚簇索引。
  ```

  综上所述，B+树有以下特点：

  - 每个节点中子节点的个数不能超过 N，也不能小于 N/2(不然会造成页分裂或页合并)
  - 根节点的子节点个数可以不超过 m/2，这是一个例外
  - ==m 叉树只存储索引，并不真正存储数据，只有最后一行的叶子节点存储行数据。==
  - 通过链表将叶子节点串联在一起，这样可以方便按区间查找

  > 1、B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；
  >
  > 2、B+树查询速度更稳定：==B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;==
  >
  > 3、B+树天然具备排序功能：==B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高==。
  > 4、B+树全节点遍历更快：==B+树遍历整棵树只需要遍历所有的叶子节点即可==，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。


#### 聚簇索引与非聚簇索引

**聚簇索引**：将数据存储与索引放到了一块，找到索引也就找到了数据

**非聚簇索引**：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行



#### MySQL有哪些索引？常用什么做索引？

**B+树索引、哈希索引、全文索引、空间数据索引**

哈希索引查找速度非常快!但是哈希索引也有它的劣势，如下：

1. 针对哈希索，==只有精确匹配索引所有列的查询才有效==，比如我在列(A,B)上建立了哈希索引，如果只查询数据列 A，则无法使用该索引。
2. 哈希索引并不是按照索引值顺序存存储的，所以也就无法用于排序，也就是说==无法根据区间快速查找==
3. 哈希索引只包含哈希值和行指针，不存储字段值，所以不能使用索引中的值来避免读取行，不过，由于哈希索引多数是在内存中完成的，大部分情况下这一点不是问题
4. 哈希索引只支持等值比较查询，包括 =,IN()，不支持任何范围的查找，如 age > 17

> 哈希索引能以 O(1) 时间进行查找，但是失去了有序性：
>
> - ==无法用于排序与分组==；
> - 只支持精确查找，==无法用于部分查找和范围查找==。
>
> InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

**全文索引**

**跳表：**

跳表是在链表之上加上多层索引构成的。如下图所示

![preview](..\Study_Notes\图片\跳表)

​		假设我们现在要查找区间 7- 13 的记录，再也不用从头开始查找了，只要在上图中的二级索引开始找即可，遍历三次即可找到链表的区间位置，时间复杂度是 O(logn)，

**平衡二叉树：**

![image-20210315201621190](..\Study_Notes\图片\平衡为叉树)

改造成为B+树：

![img](..\Study_Notes\图片\B+树)

​		可以看到主要区别就是所有的节点值都在最后叶节点上用双向链表连接在了一起，仔细和跳表对比一下 ，是不是很像，现在如果我们要找15 ~ 27 这个区间的数只要先找到 15 这个节点(时间复杂度 logn = 3 次)再从前往后遍历直到 27 这个节点即可，即可找到这区间的节点，这样它完美地支持了我们提的三个需求：快速查找值，区间，顺序逆序查找

​	节点过多导致内存消耗严重，内存中装载一个B+树索引有问题，怎么解决呢？

内存放不下， 我们可以把它放到磁盘嘛，磁盘空间比内存大多了，但新的问题又来了，我们知道内存与磁盘的读取速度相差太大了，通常内存是纳秒级的，而磁盘是毫秒级的，读取同样大小的数据，两者可能相差上万倍，于是上一步我们计算的 27 次查询如果放在磁盘中来看就非常要命了(查找一个节点可以认为是一次磁盘 IO，也就是说有 27 次磁盘 IO!)，27 次查询是否可以优化?

可以很明显地观察到查询次数和树高有关，那树高和什么有关，很明显和每个节点的子节点个数有关，即 N 叉树中的 N，假设现在有 16 个数，我们分别用二叉树和五叉树来构建，看下树高分别是多少；二叉树树高为4；五叉树树高为3；

回过头来看 上文的一亿个节点，如果我们用 100 叉树来构建，需要几次 IO 呢，可以看到，最多遍历五次(实际上根节点一般存在内存里的，所以可以认为是 4 次)!磁盘 IO 一下从 27 减少到了 5!性能可以说是大大提升了,有人说 5 次还是太多，是不是可以把 100 叉树改成 1000 或 10000 叉树呢，这样 IO 次数不就就能进一步减少了。

这里我们就需要了解页(page)的概念，在计算机里，无论是内存还是磁盘，操作系统都是按页的大小进行读取的(页大小通常为 4 kb)，磁盘每次读取都会预读，会提前将连续的数据读入内存中，这样就避免了多次 IO，这就是计算机中有名的==局部性原理==，即我用到一块数据，很大可能这块数据附近的数据也会被用到，干脆一起加载，省得多次 IO 拖慢速度， 这个连续数据有多大呢，==必须是操作系统页大小的整数倍==，这个连续数据就是 MySQL 的页，默认值为 16 KB，也就是说对于 B+ 树的节点，最好设置成页的大小(16 KB)，这样一个 B+ 树上的节点就只会有一次 IO 读。

那有人就会问了，这个页大小是不是越大越好呢，设置大一点，节点可容纳的数据就越多，树高越小，IO 不就越小了吗，这里要注意，页大小并不是越大越好，==InnoDB 是通过内存中的缓存池(pool buffer)来管理从磁盘中读取的页数据的==。页太大的话，很快就把这个缓存池撑满了，可能会造成页在内存与磁盘间频繁换入换出，影响性能。

通过以上分析，相信我们不难猜测出 N 叉树中的 N 该怎么设置了，==只要选的时候尽量保证每个节点的大小等于一个页(16kb)的大小即可==。





#### 为什么用B+树?B+树怎么省IO？

B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能==中序遍历==所有节点，效率太低。

（一）B+ 树有更低的树高

平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。

（二）磁盘访问原理

操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。

如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。

（三）磁盘预读特性

为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。

#### MVCC原理

通过数据行的多个版本管理来实现数据库的并发控制，简单来说就是保存数据的历史版本。可以通过比较版本号决定数据是否显示出来。**读取数据的时候不需要加锁可以保证事务的隔离效果**。

**MVCC 可以解决什么问题？**

1. 读写之间阻塞的问题，通过 MVCC 可以让读写互相不阻塞，读不相互阻塞，写不阻塞读，这样可以提升数据并发处理能力。
2. 降低了死锁的概率，这个是因为 MVCC 采用了乐观锁的方式，读取数据时，不需要加锁，写操作，只需要锁定必要的行。
3. 解决了一致性读的问题，当我们朝向某个数据库在时间点的快照是，只能看到这个时间点之前事务提交更新的结果，不能看到时间点之后事务提交的更新结果。

#### 数据库引擎(Innodb和Myisam)

MyISAM、InnoDB。从MySQL5.5版本之后，MySQL的默认内置存储引擎是**InnoDB**

1. InnoDB 支持事务、支持所有隔离级别、行级锁、外键关联、灾难恢复性好、索引和数据是在一起的、用的B+树。不保存行列的信息，使用select需要扫描全表，查找慢些。
2. MyISAM 不支持事务、不支持行级锁、外键关联，灾难恢复性差、在读写的时候需要锁住整个表，效率低些。但是查找的时候保持行列信息，通过select可以查找相对比较快，索引和数据是分开的、用的B+树。

> - 事务: InnoDB 是事务型的，可以使用 `Commit` 和 `Rollback` 语句。
> - 并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
> - 外键: InnoDB 支持外键。
> - 备份: InnoDB 支持在线热备份。
> - 崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
> - 其它特性: MyISAM 支持压缩表和空间数据索引。

#### 事务的隔离级别

> 事务的**隔离性**就是指，多个并发的事务同时访问一个数据库时，一个事务不应该被另一个事务所干扰，每个并发的事务间要相互进行隔离。
>
> 1. **读未提交**（Read Uncommitted）：因为没有行级共享锁，会出现**脏读**。
>
>    脏读就是，比如两个事务都在操作同一个表，A事务修改了C字段的值没有提交该事务；而B事务也在读取C字段的值，就在这时A事务发生了失败回滚，那么C字段的值返回原来的值，所以B事务发生了脏读。**整个过程结束，数据库没有发生任何改变，B事务却读到了奇怪的值，这就是脏读**。解决办法是行级共享锁。
>
> 2. **读提交**（Read Committed）：通过行级共享锁，解决了脏读问题，但因为事务没有加锁，导致前后读取数据不一致，即**不可重复读**。
>
>    不可重复读就是，比如两个事务都在操作同一个表，A事务先读取了C字段的值后继续操作下一个字段；而B事务在这个时候修改了C字段的值。A事务再读取C字段的值，发现同一个事务下，竟然前后两次读取不一样，这就很怪异了，这就是**不可重复读**。解决办法是对事务进行加锁。
>
> 3. **可重复读**（Repeated Read）：通过事务加锁，解决了不可重复读问题，但因为表没有加锁，会出现**幻读**的情况，比如多了一行数据。
>
>    幻读就是，比如两个事务都在操作同一个表，A事务先读取了表的行数；而B事务在这个时候为表格新插入了一行数据。A事务再读取表的行数，发现竟多了一行，这就很怪异了，这就是**幻读**。解决办法是对表进行加锁。
>
> 4. 串行化（Serializable）：可解决脏读、不可重复读、幻读问题，**通过对表直接加锁的方式，但数据库的读取效率降低**。
>
> mysql默认隔离级别为**可重复读**。

#### 关系型数据库和非关系型数据库的区别

1. **关系型数据库**：指采用了关系模型来组织数据的数据库。
   关系模型指的就是**二维表格模型**，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。比如==mysql==就是关系型数据库。

2. **非关系型数据库**：指非关系型的，分布式的，且一般不保证遵循`ACID`原则的数据存储系统。

   非关系型数据库结构

   非关系型数据库以**键值对**存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限于固定的结构，可以减少一些时间和空间的开销。

   如典型的==Redis==就是非关系型数据库

## 数据结构与算法

#### 二叉搜索树

二叉查找树的特点就是**左子树的节点值比父亲节点小，而右子树的节点值比父亲节点大**；

基于二叉查找树的这种特点，我们在查找某个节点的时候，可以采取类似于**二分查找**的思想，快速找到某个节点。

n 个节点的二叉查找树，正常的情况下，查找的时间复杂度为**==O（logn）==。**

存在极端的情况，二叉搜索树退化为链表，这样的二叉查找树的查找时间复杂度顿时变成了 **O(n)**，可想而知，我们必须不能让这种情况发生，为了解决这个问题，于是我们引申出了**平衡二叉树**。

#### 平衡二叉树（AVL）

左右子树都是平衡二叉树，且左右子树的深度差值的绝对值不大于1.

通过平衡树，我们解决了二叉查找树的缺点。对于有 n 个节点的平衡树，最坏的查找时间复杂度也为 **O(logn)**。

#### 为什么有了平衡树还需要红黑树？

​		虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O(logn)，不过却不是最佳的，因为平衡树要求**每个节点的左子树和右子树的高度差至多等于1**，这个**要求实在是太严了**，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过**左旋**和**右旋**来进行调整，使之再次成为一颗符合要求的平衡树。

显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了**红黑树**，红黑树具有如下特点：

#### 红黑树

https://www.cnblogs.com/skywang12345/p/3245399.html

**红黑树的特性**:
**（1）每个节点或者是黑色，或者是红色。**
**（2）根节点是黑色。**
**（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点**
**（4）如果一个节点是红色的，则它的子节点必须是黑色的。**
**（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。**



![img](https://i.loli.net/2021/04/02/rHaysKip4QXbL79.jpg)

C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。

正是由于红黑树的这种特点，使得它能够在最坏情况下，也能在 **O(logn)**的时间复杂度查找到某个节点。

不过，与平衡树不同的是，红黑树在插入、删除等操作，**不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整**，这也是我们为什么大多数情况下使用红黑树的原因。

红黑树就是非严格的平衡树，==插入最多旋转两次，删除最多旋转三次==。比平衡树效率高很多

如果你要说，单单在查找方面的效率的话，平衡树比红黑树快。

所以，我们也可以说，**红黑树是一种不大严格的平衡树**。也可以说是一个折中发方案；

**平衡树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。**

#### 说说map和set的区别

在C++中，容器map和set都是用红黑树实现的，但是两者也有区别，具体如下：

（1）map：经过排序了的二元组的集合，map中的每个元素都是由两个值组成，其中的key（键值，一个map中的**键值必须是唯一的**） 是在排序或搜索时使用，它的值可以在容器中重新获取；而另一个值是该元素关联的数值。

（2）set：包含了经过排序了的数据，这些数据的**值(value)必须是唯一的**。和 map容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。所以我们可以认为set就是**元素的集合**，如 {'a','b','c'} 。

（3）map和set的底层实现机制：**红黑树**（RB-Tree）。

#### 字典树

Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较。

Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

通常字典树的查询时间复杂度是O(logL)，L是字符串的长度。所以效率还是比较高的。

```cpp
class Trie {
private:
    bool isEnd;
    Trie* next[26];
public:
    Trie() {
        isEnd = false;
        memset(next, 0, sizeof(next));
    }

    void insert(string word) {
        Trie* node = this;
        for (char c : word) {
            if (node->next[c-'a'] == NULL) {
                node->next[c-'a'] = new Trie();
            }
            node = node->next[c-'a'];
        }
        node->isEnd = true;
    }

    bool search(string word) {
        Trie* node = this;
        for (char c : word) {
            node = node->next[c - 'a'];
            if (node == NULL) {
                return false;
            }
        }
        return node->isEnd;
    }

    bool startsWith(string prefix) {
        Trie* node = this;
        for (char c : prefix) {
            node = node->next[c-'a'];
            if (node == NULL) {
                return false;
            }
        }
        return true;
    }
};
```



#### 图的遍历（邻接表，链式前向星数组模拟）

```cpp
#include<iostream>

using namespace std;

const int N = 30010;
int h[N], e[N], ne[N], ind=1;

void add(int a, int b) {
	e[ind] = b;
	ne[ind] = h[a];
	h[a] = ind++;
}

int main() {
	int n, m;
	cin >> n >> m;
	memset(h, -1, sizeof h);
	for (int i = 1; i <=m; i++) {
		int a, b;
		cin >> a >> b;
		add(a, b);
	}
	for (int i = 1; i <= m; i++) {
		cout << e[i] << " " << h[i] << " " << ne[i] << endl;
	}
    
	for (int i = 1; i <= n; i++) {
		for (int j = h[i]; j = -1; j = ne[j]) {
			int k = e[j];//i号点所有的邻点；
			cout << "i" << i << " " << k << endl;
		}
	}
	return 0;
}
//-------------------测试---------
4 5
1 4
4 3
1 2
2 4
1 3
4 5 -1
3 4 -1
2 -1 1
4 2 -1
3 -1 3
i1 3
i1 2
i1 4
i2 4
i4 3
```

#### 拓扑排序

对一个[有向无环图](https://baike.baidu.com/item/有向无环图/10972513)(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边<u,v>∈E(G)，则u在线性序列中出现在v之前

```cpp
queue<int>q;
//priority_queue<int,vector<int>,greater<int>>q;
//优先队列的话，会按照数值大小有顺序的输出
//此处为了理解，暂时就用简单队列
int topo()
{
    for(int i=1;i<=n;i++)
    {
        if(indegree[i]==0)
        {
            q.push(i);
        }
    }
 
    int temp;
    while(!q.empty())
    {
        temp=q.front();//如果是优先队列，这里可以是top()
        printf("%d->",temp);
        q.pop();
        for(int i=1;i<=n;i++)//遍历从temp出发的每一条边，入度--
        {
            if(map[temp][i])
            {
                indegree[i]--;
                if(indegree[i]==0)q.push(i);
            }
        }
    }
}
//接续上面邻接表实现
void topsort()
{
    queue<int> q;

    for (int i = 1; i <= n; i ++ )
        //d[i]表示节点i的入度。
        if (!d[i])
            q.push(i);

    int k = 0;
    while (q.size())
    {
        int t = q.front();
        q.pop();
        //用seq数组记录top排序的顺序。
        seq[k ++ ] = t;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q.push(j);
        }
    }
}

```

## Linux

#### **查看进程运行状态的指令、查看内存使用情况的指令**

> 1. **查看进程运行状态的指令**：ps命令。“**ps -aux | grep PID**”，用来查看某PID进程状态
> 2. **查看内存使用情况的指令**：free命令。“**free -m**”，命令查看内存使用情况。
> 3. 使用top命令；

#### 简述GDB常见的调试命令，什么是条件断点，多进程下如何调试

**GDB调试**：gdb调试的是可执行文件，在gcc编译时加入 -g ，告诉gcc在编译时加入调试信息，这样gdb才能调试这个被编译的文件 `gcc -g test.c -o test`

**GDB命令格式：**

1. `quit`：退出gdb，结束调试

2. `list`：查看程序源代码

   `list 5，10`：显示5到10行的代码

   `list test.c:5, 10`: 显示源文件5到10行的代码，在调试多个文件时使用

   `list get_sum`: 显示get_sum函数周围的代码

   list test,c get_sum`: 显示源文件get_sum函数周围的代码，在调试多个文件时使用

3. `reverse-search`：字符串用来从当前行向前查找第一个匹配的字符串

4. `run`：程序开始执行

5. `help list/all`：查看帮助信息

6. `break`：设置断点

   `break 7`：在第七行设置断点

   `break get_sum`：以函数名设置断点

   break 行号或者函数名 if 条件：以条件表达式设置断点

7. `watch `条件表达式：条件表达式发生改变时程序就会停下来

8. `next`：继续执行下一条语句 ，会把函数当作一条语句执行

9. `step`：继续执行下一条语句，会跟踪进入函数，一次一条的执行函数内的代码

**条件断点：**break if 条件 以条件表达式设置断点

**多进程下如何调试：**用`set follow-fork-mode child` 调试子进 或者`set follow-fork-mode parent `调试父进程



#### exit()和\_exit()和return区别

 exit()和\_exit()函数都可以用于结束进程，不过_exit()调用之后会立即进入内核，而exit()函数会先执行一些清理之后才会进入内核，比如调用各种终止处理程序，关闭所有I/O流等。

exit()和\_exit()最大的区别在于exit()函数在调用exit系统调用之前要检查文件的打开情况，把文件缓冲区中的内容写回文件。

exit()和\_exit()函数调用时会结束进程，他们的区别在于结束时两者所做的清理工作不同，exit()会再退出程序之前关闭所有打开的文件，清空标准输入输出缓冲区，最后执行atexit()注册的回调函数（在main中使用return效果和exit()一样）,而\_exit()则不会关闭打开的文件，不会清空缓冲区，也不会执行atexit()注册的回调函数，这一切由内核接管执行处理。

\_exit()函数是**系统调用**。直接使进程停止运行，会清理内存和包括pcb（内核描述进程的主要数据结构）在内的数据结构，但是不会刷新流，而exit()函数会刷新流。比如exit()函数会将I/O缓冲中的数据写出或读入（printf()就是I/O缓冲,遇到‘\n'才会刷新，若直接调用exit()则会刷新,而\_exit()则不会刷新）。

**return 不是系统调用**，也不是库函数，而是一个关键字，表示**调用堆栈的返回**（过程活动记录），是函数的退出，而不是进程的退出；只能返回当前函数，常用于获取函数的返回值，只有在main函数中国才能起到退出程序的作用，而在子程序中只能返回上一级调用程序。

**abort()函数用于异常退出。**返回一个错误代码。错误代码的缺省值是3。abort()函数导致程序非正常退出除非sigabrt信号被捕捉到，并且信号处理函数没有返回（即abort()函数给自己发送sigabrt信号），如果abort()函数导致程序终止，所有的打开的流将被关闭并且刷新

## 设计模式

### 单例（Singleton）

#### Intent

==确保一个类只有一个实例，并提供该实例的全局访问点。==

#### Class Diagram

使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。

私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eca1f422-8381-409b-ad04-98ef39ae38ba.png"/> </div><br>



#### c++实现

```cpp
#include<stdlib.h>
#include<cstdio>
#include<iostream>
#include<pthread.h>

using namespace std;

//懒汉模式1 堆区内存泄漏，new没有delete，不支持多线程
#if 0 
class Singleton{
public:
    static Singleton* getInstance(){
        if(m_instance == nullptr){
            m_instance = new Singleton();
        }
        return m_instance;
    }

private:
    Singleton(){
        cout << "this is Singleton design pattern!"<<endl;
    }
    static Singleton *m_instance;
};
//静态成员变量要在类外初始化
Singleton *Singleton::m_instance = nullptr;
#endif

//懒汉模式2 添加析构函数
#if 0
class Singleton{
public:
    static Singleton *getInstance(){
        if(m_instance == nullptr){
            m_instance = new Singleton();
            atexit(Destructor);
        }
        return m_instance;
    }

private:
    static void Destructor(){
        if(m_instance != nullptr){
            delete m_instance;
            m_instance = nullptr;//防止野指针
        }
    }
    static Singleton *m_instance;
    Singleton(){
        cout << "this is Singleton design pattern!"<<endl;
    }
};
//静态成员变量要在类外初始化
Singleton *Singleton::m_instance = nullptr;
#endif

/*
new函数原理
1. 分配内存
2. 调用构造函数
3. 赋值指针，多线程环境下，cpu指令reorder，1，3，2，这样先赋值指针，是一个野指针。
*/

//懒汉模式 3 双重检测 支持多线程
/*
*/
#if 0
class Singleton{
public:
    static Singleton* getInstance(){
        if(m_instance == nullptr){
           pthread_mutex_t mutex;
           pthread_mutex_lock(&mutex); //加锁
            if(m_instance == nullptr){
                m_instance = new Singleton(); //new 可能出现指令重排 看以下
                atexit(Destructor);
            }
            pthread_mutex_unlock(&mutex);//解锁
        }
        return m_instance;
    }
private:
    static void Destructor(){
        if(m_instance != nullptr){
            delete m_instance;
            m_instance = nullptr;//防止野指针
        }
    }
    static Singleton *m_instance;
    Singleton(){
        cout << "this is Singleton design pattern!"<<endl; 
    }
};
//静态成员变量要在类外初始化
Singleton *Singleton::m_instance = nullptr;
#endif

/*
懒汉模式4 C++11特性，使用静态局部变量不用加锁
1、利用静态局部变量的特性，延迟加载；
2、利用静态局部变量的特性，系统自动回收内存，自动调用析构函数;
3、静态局部变量初始化时，没有new操作带来的cpu指令reoder操作；
4、c++ 11静态局部变量初始化时，具备线程安全;
*/
#if 0
class Singleton{
public:
    ~Singleton(){}
    static Singleton* getInstance(){
        static Singleton m_instance; //一定要加static关键字
        return &m_instance;
    }
private:
    Singleton(){
        cout << "this is Singleton design pattern!"<<endl; 
    }
};
#endif

/*饿汉模式：初始即实例化
饿汉模式会提前浪费内存空间和资源，一般推荐使用懒汉式
*/
#if 1
class Singleton{
public:
    static Singleton* getInstance(){
        return m_instance;
    }
private:
    static Singleton *m_instance;
    Singleton(){
        cout << "this is Singleton design pattern!"<<endl; 
    }
};

Singleton* Singleton::m_instance = new Singleton();
#endif


int main(){
    //Singleton s;
    Singleton:: getInstance(); //静态成员函数通过类名来访问
    return 0;
}
```



```cpp
#include<iostream>
using namespace std;

class Singleton{
public:
	static Singleton* getInstance(){
		if(_instance == 0){
			_instance = new Singleton();
		}
		return _instance;
	}
private:
	static Singleton* _instance;
	Singleton(){
		cout<<"singleton..."<<endl;
	}
};

Singleton *Singleton::_instance = 0;//The C++ standard allows only static constant integral or enumeration types to be initialized inside the class

int main(){
	Singleton* sgn1 = Singleton::getInstance();
	Singleton* sgn2 = Singleton::getInstance();
	delete sgn1;
//	delete sgn2; //sgn1 share same point with sgn2, so deleting sgn2 will make error
}**
```



​	最基础的版本：

```c++
//一个私有构造函数，一个私有静态成员变量，一个公有静态成员函数，保证不能创建实例，只能通过公有静态成员函数调用私有构造函数创建唯一实例
class Singleton{
pubilc:
    static Singleton* GetInstance(){
        if(_instance==nullptr){
            _instance=new Singleton();//存储在堆区;
        }
        return _instance;
    }
private:
    Singleton(){}//私有构造函数;
    Singleton(const Singleton &clone){}
    Singleton& operator=(const Singleton&){}
    static Singleton* _instance;//存储在静态全局区
}
Singleton* Singleton::_instance==nullptr;//静态成员变量只能在类外初始化
```

问题

> 堆区内存泄漏，不支持多线程

**版本2：**

```cpp
class Singleton{
public:
    //公有静态成员函数，只能调用静态成员函数;
    static Singleton* GetInstance(){
        if(_instance==nullptr){
            _instance=new Singleton();
            atexit(Destructor);//添加析构，防止内存泄漏;程序退出时，正常
        }
        return _instance;
    }
private:
    static void Destructor(){
        if(_instance!=nullptr){
            delete _instance;
            _instance=nullptr;
        }
    }
    Singleton(){}//私有构造函数
    static Singleton *_instance;//私有静态成员变量；
};

Singleton* Singleton::_instance=nullptr;//静态成员变量类外初始化；

```

**版本3**

```cpp
#include<iostream>
#include<mutex>
using namespace std;

//懒汉模式 vs下面
class Singleton{
public:
    //共有静态成员函数
    static Singleton* GetInstance(){
        //std::lock_guard<std::mutex>lock(_mutex);//加入互斥锁 3.1切换线程；
        //锁的粒度太大了
        if(_instance==nullptr){
           	std::lock_guard<std::mutex>lock(_mutex);//3.2 加两把锁 双检测;
            if(_instance == nullptr){
            	_instance=new Singleton();
            	atexit(Destructor);
            }
        }
        return _instance;
    }
private:
    static void Destructor(){
        if(_instance!=nullptr){
            delete _instance;
            _instance=nullptr;
        }
    }
    Singleton(){}//私有构造函数
    static Singleton *_instance;//私有静态成员变量；
    static std::mutex _mutex;
};

Singleton* Singleton::_instance=nullptr;//静态成员变量类外初始化；

```

> new函数原理
>
> 1. 分配内存
> 2. 调用构造函数
> 3. 赋值指针，多线程环境下，cpu指令重排 reorder，1，3，2，这样先赋值指针，是一个野指针。

```cpp
//懒汉模式，linux;
#include<iostream>
#include<pthread.h>

using namespace std;

class singleInstance{
public:
    static singleInstance* GetsingleInstance(){
        if(instance==NULL){
            pthread_mutex_t mutex;//mutex mlock; 加锁互斥
            pthread_mutex_lock(&mutex);//加锁
            if(instance==NULL){
                instance=new singleInstance();
            }
            pthread_mutex_unlock(&mutex);//解锁
        }
        return instance;
    }
private:
    singleInstance(){}
    singleInstance(const singleInstance& other){}
    singleInstance& operator=(const singleInstance& other){return *this;}
    static singleInstance* instance;
};

singleInstance* singleInstance::instance=NULL;
int main(){
    singleInstance* s=singleInstance::GetsingleInstance();
    return 0;
}

```

**版本4 **（c++ 11解决cpu  new reoder）

```

```

**版本5**

```cpp
class Singleton{
public:
	~Singleton(){}
    staitc Singleton& GetInstance(){
        static Singleton instance;
        return instance;
    }
private:
    Singleton();
    Singleton(const Singleton&);
    Singleton& operator=(const Singleton&){}
};
/*
1、利用静态局部变量的特性，延迟加载；
2、利用静态局部变量的特性，系统自动回收内存，自动调用析构函数;
3、静态局部变量初始化时，没有new操作带来的cpu指令reoder操作；
4、c++ 11静态局部变量初始化时，具备线程安全;
*/
```

**版本6**

```cpp
template<typename T>
class Singleton{
public:
    static T& GetInstance(){
        static T instance;
        return instance;
    }
protected:
    virtual ~Singleton(){}
    Singleton(){}
    Singleton(const Singleton&){}
    Singleton& operator=(const Singleton&){}
};
class DesignPattern:public(Singleton<DesignPattern>){
    friend class Singleton<DesignPattern>;
 private:
    DesignPattern(){};
    DesignPattern(const DesignPattern&){}
    DesignPattern& operator=(const DesignPattern&){}
}
```

```cpp
class Singleton{
public:
    static Singleton* GetInstance(){
        if(instance==nullptr){
            instance=new Singleton();
            atexti(Desconstructor);
        }
        return instance;
    }
private:
    static void Desconstructor(){
        if(instance!=nullptr){
            delete instance ;
            instance =nullptr;
        }
    }
	static Singleton* instance;
    Singleton(){};
};
```



### 工厂模式

要点：

> 隐藏对象真实类型；
>
> 对象创建会很多参数来决定如何创建；
>
> 创建对象具有复杂的依赖关系；



实现一个导出数据的接口，让客户选择数据的导出方式；

就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。

#### 简单工厂模式

```cpp
#include<iostream>
using namespace std;

//产品类，抽象类，不能实例化;
class Product{
public:
    Product(){};
    virtual void show()=0;//纯虚函数；
};

class ProductA:public Product{
public:
    ProductA(){};
    void show(){ cout<<"Product A Created!"<<endl; }
    ~ProductA();
};
class ProductB:public Product{
public:
    ProductB(){};
    void show(){ cout<<"Product B Created!"<<endl; }
    ~ProductB();
};

class SimpleFactory{
private:
    Product *m;
public:
    SimpleFactory(){};
    Product* Produce(const string str){
        if(str=="ProductA") m=new ProductA();
        if(str=="ProductB") m=new ProductB();
        return m;
    }
};

int main(){
    SimpleFactory obj;
    Product* pro;
    pro=obj.Produce("ProductA");
    pro->show();
    pro=obj.Produce("ProductB");
    pro->show();
    delete pro;
    return 0;
}

```

工厂模式为的就是代码解耦，如果我们不采用工厂模式，如果要创建产品A、B，我们通常做法是不是用switch...case语句？那麻烦了，代码耦合程度高，后期添加更多的产品进来，我们不是要添加更多的case吗？这样就太麻烦了，而且不符合设计模式中的**开放封闭原则**.

为了进一步解耦，在简单工厂的基础上发展出了抽象工厂模式，即连工厂都抽象出来，实现了进一步代码解耦。代码如下

#### 抽象工厂模式

```cpp
#include<iostream>
using namespace std;

//产品类，抽象类，不能实例化;
class Product{
public:
    Product(){};
    virtual void show()=0;//纯虚函数；
};

class ProductA:public Product{
public:
    ProductA(){};
    void show(){ cout<<"Product A Created!"<<endl; }
    ~ProductA();
};
class ProductB:public Product{
public:
    ProductB(){};
    void show(){ cout<<"Product B Created!"<<endl; }
    ~ProductB();
};

class Factory{
public:
    virtual Product* CreateProduct()=0;
};
//工厂类A，只生产A类产品：
class FactoryA:public Factory{
public:
    Product* CreateProduct(){
        Product* _Product =nullptr;
        _Product =new ProductA();
        return _Product;
    }
};

class FactoryB:public Factory{
public:
    Product* CreateProduct(){
        Product* _Product =nullptr;
        _Product =new ProductB();
        return _Product;
    }
};
int main(){
    Product* _Product=nullptr;
    auto MyFactoryA=new FactoryA();
    _Product=MyFactoryA->CreateProduct();//调用产品A的工厂来生产A产品;
    _Product->show();
    delete _Product;

    auto MyFactoryB=new FactoryB();
    _Product=MyFactoryB->CreateProduct();//调用产品A的工厂来生产A产品;
    _Product->show();
    delete _Product;
    return 0;
}

```

### 观察者模式

观察者模式的作用是：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

比如拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。

```cpp
#include<iostream>
#include<list>
using namespace std;
//抽象观察者
class Observer{
public:
    //所有观察者都必须实现update方法：
    virtual void Upadate(int )=0;
};
//被观察者抽象；
class Subject{
public:
    virtual void Attach(Observer*)=0;//注册观察者
    virtual void Detach(Observer*)=0;//删除观察者
    virtual void Notify()=0;//主题改变时，调用该函数通知所有的观察者，
};

class DisplayElement{
public:
    void display();//当需要显示的时候调用这个函数;
};

class ConcreteObserver1:public Observer{
public:
    ConcreteObserver1(Subject *pSubject):m_pSubject(pSubject){}
    void Upadate(int value){
        cout<<"ConcreteObserver1 get the Upadate .New State: "<<value<<endl;
    }
private:
    Subject *m_pSubject;
};

class ConcreteObserver2:public Observer{
public:
    ConcreteObserver2(Subject *pSubject):m_pSubject(pSubject){}
    void Upadate(int value){
        cout<<"ConcreteObserver2 get the Upadate .New State: "<<value<<endl;
    }
private:
    Subject *m_pSubject;
};

//具体的主题成原变量：存储观察者的链表，设置状态的函数和值；
class ConcreteSubject:public Subject{
public:
    void Attach(Observer *pObserver);
    void Detach(Observer *pObserver);
    void Notify();
    void SetState(int state){
        m_iState=state;
    }
private:
    list<Observer *>m_ObserverList;
    int m_iState;
};

void ConcreteSubject::Attach(Observer *pObserver){
    m_ObserverList.push_back(pObserver);
}

void ConcreteSubject::Detach(Observer *pObserver){
    m_ObserverList.remove(pObserver);
}

void ConcreteSubject::Notify(){
    list<Observer *>::iterator it=m_ObserverList.begin();
    while(it!=m_ObserverList.end()){
        (*it)->Upadate(m_iState);
        ++it;
    }
}

int main(){
    //创建被观察者
    ConcreteSubject *pSubject = new ConcreteSubject();
    //创建 观察者
    ConcreteObserver1 *pObserver1 = new ConcreteObserver1(pSubject);
    ConcreteObserver2 *pObserver2 = new ConcreteObserver2(pSubject);
    //改变状态
    pSubject->SetState(2);
    //注册观察者
    pSubject->Attach(pObserver1);
    pSubject->Attach(pObserver2);
    //通知观察者
    pSubject->Notify();
    //删除观察者
    pSubject->Detach(pObserver1);

    pSubject->SetState(3);
    pSubject->Notify();

    delete pObserver1;
    delete pObserver2;
    delete pSubject;
    return 0;
}

```

## 常见手撕代码

#### shared_ptr实现

```cpp
template<typename T>
class myshared_ptr{
public:
    myshared_ptr(T *ptr){
        m_ptr=ptr;
        m_count=new int (0);
        ++(*m_count);
    }
    myshared_ptr(const myshared_ptr<T>& other){
        m_ptr=other.m_ptr;
        m_count=other.m_count;
        ++(*m_count);//拷贝构造，自身的引用计数器加1：
    }
    myshared_ptr<T>& operator=(const myshard_ptr<T>& other){
        ++(*other.m_count);
        --(*m_count);
        if((*m_count)==0){
            delete m_count;
            m_count=nullptr;
            delete m_ptr;
            m_ptr=nullptr;
        }
        m_ptr=other.m_ptr;
        m_count=other.m_count;
        return *this;
    }
    ~myshared_ptr(){
        --(*m_count);
        if((*m_count)==0){
            delete m_count;
            m_count=nullptr;
            delete m_ptr;
            m_ptr=nullptr;
        }
    }
    
private:
    int* m_count;
    T* m_ptr;
};
```

